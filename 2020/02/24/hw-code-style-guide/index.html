<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="焦迪">



<meta name="description" content="&amp;emsp;本文为华为软件编程规范和范例。">
<meta name="keywords" content="C,Code Style">
<meta property="og:type" content="article">
<meta property="og:title" content="华为软件编程规范和范例">
<meta property="og:url" content="http://jiaodi.tech/2020/02/24/hw-code-style-guide/index.html">
<meta property="og:site_name" content="焦迪的博客">
<meta property="og:description" content="&amp;emsp;本文为华为软件编程规范和范例。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-02-29T05:36:25.250Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="华为软件编程规范和范例">
<meta name="twitter:description" content="&amp;emsp;本文为华为软件编程规范和范例。">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="焦迪的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="https://github.com/NemoJ/blog_pics/raw/master/blog/jay.JPG">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>华为软件编程规范和范例 | 焦迪的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://github.com/NemoJ/blog_pics/raw/master/blog/jay.JPG" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">焦迪</a></h1>
        </hgroup>

        
        <p class="header-subtitle">Shape of my heart.</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:nemojiao@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/nemoj" title="GitHub"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/802-11/">802.11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATECC508A/">ATECC508A</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Allegro/">Allegro</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Altium-Designer/">Altium Designer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Buck/">Buck</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C2000/">C2000</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCS/">CCS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cadence/">Cadence</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code-Style/">Code Style</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-Systems/">Computer Systems</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Crypto/">Crypto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DCDC/">DCDC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DDR/">DDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DMA/">DMA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DSP/">DSP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/F28379D/">F28379D</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FMC/">FMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flash/">Flash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GPIO/">GPIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git-flow/">Git flow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HDC1010/">HDC1010</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/I2C/">I2C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IWDG/">IWDG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Keil/">Keil</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LWIP/">LWIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LwIP/">LwIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MAC/">MAC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MLCC/">MLCC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MPU/">MPU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Noise/">Noise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PCB/">PCB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PDN/">PDN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHY/">PHY</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PI/">PI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWM/">PWM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pierce/">Pierce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PyInstaller/">PyInstaller</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QUADSPI/">QUADSPI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RTC/">RTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDRAM/">SDRAM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SI/">SI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STM32/">STM32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STM32CubeMX/">STM32CubeMX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STM32F7/">STM32F7</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sensor/">Sensor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Systick/">Systick</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Timer/">Timer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/">Tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UART/">UART</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WWDG/">WWDG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XDS100/">XDS100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/crystal/">crystal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interrupt/">interrupt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oscillator/">oscillator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/serial/">serial</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/串口/">串口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前馈电容/">前馈电容</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态响应/">动态响应</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/封装/">封装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/差分线/">差分线</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/等长线/">等长线</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高速电路/">高速电路</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="http://zhangxb.tech/">张晓斌</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://gaomf.cn/">高明飞</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://tongzai.tech/">桐仔</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://apex.linn.top/">Tomy Stark</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">雨下整夜，此刻初晴.</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">焦迪</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://github.com/NemoJ/blog_pics/raw/master/blog/jay.JPG" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">焦迪</a></h1>
            </hgroup>
            
            <p class="header-subtitle">Shape of my heart.</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:nemojiao@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/nemoj" title="GitHub"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap"><article id="post-hw-code-style-guide" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/24/hw-code-style-guide/" class="article-date">
      <time datetime="2020-02-24T13:25:06.000Z" itemprop="datePublished">2020-02-24</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      华为软件编程规范和范例
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/C/">C</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code-Style/">Code Style</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>&emsp;本文为<a href="https://www.cnblogs.com/Terrylee/archive/2005/12/16/298314.html" target="_blank" rel="noopener">华为软件编程规范和范例</a>。</p>
<a id="more"></a>
<h2 id="华为软件编程规范和范例"><a href="#华为软件编程规范和范例" class="headerlink" title="华为软件编程规范和范例"></a>华为软件编程规范和范例</h2><h3 id="1-排版"><a href="#1-排版" class="headerlink" title="1 排版"></a>1 排版</h3><h4 id="1-1：程序块要采用缩进风格编写，缩进的空格数为4个。"><a href="#1-1：程序块要采用缩进风格编写，缩进的空格数为4个。" class="headerlink" title="1-1：程序块要采用缩进风格编写，缩进的空格数为4个。"></a>1-1：程序块要采用缩进风格编写，缩进的空格数为4个。</h4><p>说明：对于由开发工具自动生成的代码可以有不一致。</p>
<h4 id="1-2：相对独立的程序块之间、变量说明之后必须加空行。"><a href="#1-2：相对独立的程序块之间、变量说明之后必须加空行。" class="headerlink" title="1-2：相对独立的程序块之间、变量说明之后必须加空行。"></a>1-2：相对独立的程序块之间、变量说明之后必须加空行。</h4><p>示例：如下例子不符合规范。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!valid_ni(ni))</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br><span class="line">repssn_ind = ssn_data[index].repssn_index;</span><br><span class="line">repssn_ni  = ssn_data[index].ni;</span><br></pre></td></tr></table></figure>
<p>应如下书写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!valid_ni(ni))</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repssn_ind = ssn_data[index].repssn_index;</span><br><span class="line">repssn_ni  = ssn_data[index].ni;</span><br></pre></td></tr></table></figure>
<h4 id="1-3：较长的语句（-gt-80字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。"><a href="#1-3：较长的语句（-gt-80字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。" class="headerlink" title="1-3：较长的语句（&gt;80字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。"></a>1-3：较长的语句（&gt;80字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。</h4><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">perm_count_msg.head.len = NO7_TO_STAT_PERM_COUNT_LEN</span><br><span class="line"></span><br><span class="line">                          + STAT_SIZE_PER_FRAM * <span class="keyword">sizeof</span>( _UL );</span><br><span class="line"></span><br><span class="line">act_task_table[frame_id * STAT_TASK_CHECK_NUMBER + index].occupied</span><br><span class="line">              = stat_poi[index].occupied;</span><br><span class="line"></span><br><span class="line">act_task_table[taskno].duration_true_or_false</span><br><span class="line">              = SYS_get_sccp_statistic_state( stat_item );</span><br><span class="line"></span><br><span class="line">report_or_not_flag = ((taskno &lt; MAX_ACT_TASK_NUMBER)</span><br><span class="line">                      &amp;&amp; (n7stat_stat_item_valid (stat_item))</span><br><span class="line">                      &amp;&amp; (act_task_table[taskno].result_data != <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<h4 id="1-4：循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分，长表达式要在低优先级操作符处划分新行，操作符放在新行之首。"><a href="#1-4：循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分，长表达式要在低优先级操作符处划分新行，操作符放在新行之首。" class="headerlink" title="1-4：循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分，长表达式要在低优先级操作符处划分新行，操作符放在新行之首。"></a>1-4：循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分，长表达式要在低优先级操作符处划分新行，操作符放在新行之首。</h4><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((taskno &lt; max_act_task_number)</span><br><span class="line">    &amp;&amp; (n7stat_stat_item_valid (stat_item)))</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; (i &lt; BufferKeyword[word_index].word_length)</span><br><span class="line">                    &amp;&amp; (j &lt; NewKeyword.word_length); i++, j++)</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; </span><br><span class="line">     (i &lt; first_word_length) &amp;&amp; (j &lt; second_word_length); </span><br><span class="line"></span><br><span class="line">     i++, j++)</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5：若函数或过程中的参数较长，则要进行适当的划分。"><a href="#1-5：若函数或过程中的参数较长，则要进行适当的划分。" class="headerlink" title="1-5：若函数或过程中的参数较长，则要进行适当的划分。"></a>1-5：若函数或过程中的参数较长，则要进行适当的划分。</h4><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n7stat_str_compare((BYTE *) &amp; stat_object,</span><br><span class="line">                   (BYTE *) &amp; (act_task_table[taskno].stat_object),</span><br><span class="line">                   <span class="keyword">sizeof</span> (_STAT_OBJECT));</span><br><span class="line"></span><br><span class="line">n7stat_flash_act_duration( stat_item, frame_id *STAT_TASK_CHECK_NUMBER</span><br><span class="line">                                      + index, stat_object );</span><br></pre></td></tr></table></figure>
<h4 id="1-6：不允许把多个短语句写在一行中，即一行只写一条语句。"><a href="#1-6：不允许把多个短语句写在一行中，即一行只写一条语句。" class="headerlink" title="1-6：不允许把多个短语句写在一行中，即一行只写一条语句。"></a>1-6：不允许把多个短语句写在一行中，即一行只写一条语句。</h4><p>示例：如下例子不符合规范。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rect.length = <span class="number">0</span>;  rect.width = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>应如下书写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect.length = <span class="number">0</span>;</span><br><span class="line">rect.width  = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="1-7：if、for、do、while、case、switch、default等语句自占一行，且if、for、do、while等语句的执行语句部分无论多少都要加括号-。"><a href="#1-7：if、for、do、while、case、switch、default等语句自占一行，且if、for、do、while等语句的执行语句部分无论多少都要加括号-。" class="headerlink" title="1-7：if、for、do、while、case、switch、default等语句自占一行，且if、for、do、while等语句的执行语句部分无论多少都要加括号{}。"></a>1-7：if、for、do、while、case、switch、default等语句自占一行，且if、for、do、while等语句的执行语句部分无论多少都要加括号{}。</h4><p>示例：如下例子不符合规范。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pUserCR == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>应如下书写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pUserCR == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-8：对齐只使用空格键，不使用TAB键。"><a href="#1-8：对齐只使用空格键，不使用TAB键。" class="headerlink" title="1-8：对齐只使用空格键，不使用TAB键。"></a>1-8：对齐只使用空格键，不使用TAB键。</h4><p>说明：避免使用不同的编辑器阅、不同的TAB键值来编辑程序，编辑器版本不同可能会引起缩进变乱。</p>
<h4 id="1-9：函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格，case语句下的情况处理语句也要遵从语句缩进要求。"><a href="#1-9：函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格，case语句下的情况处理语句也要遵从语句缩进要求。" class="headerlink" title="1-9：函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格，case语句下的情况处理语句也要遵从语句缩进要求。"></a>1-9：函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格，case语句下的情况处理语句也要遵从语句缩进要求。</h4><h4 id="1-10：程序块的分界符（如C-C-语言的大括号‘-’和‘-’）应各独占一行并且位于同一列，同时与引用它们的语句左对齐。在函数体的开始、类的定义、结构的定义、枚举的定义以及if、for、do、while、switch、case语句中的程序都要采用如上的缩进方式。"><a href="#1-10：程序块的分界符（如C-C-语言的大括号‘-’和‘-’）应各独占一行并且位于同一列，同时与引用它们的语句左对齐。在函数体的开始、类的定义、结构的定义、枚举的定义以及if、for、do、while、switch、case语句中的程序都要采用如上的缩进方式。" class="headerlink" title="1-10：程序块的分界符（如C/C++语言的大括号‘{’和‘}’）应各独占一行并且位于同一列，同时与引用它们的语句左对齐。在函数体的开始、类的定义、结构的定义、枚举的定义以及if、for、do、while、switch、case语句中的程序都要采用如上的缩进方式。"></a>1-10：程序块的分界符（如C/C++语言的大括号‘{’和‘}’）应各独占一行并且位于同一列，同时与引用它们的语句左对齐。在函数体的开始、类的定义、结构的定义、枚举的定义以及if、for、do、while、switch、case语句中的程序都要采用如上的缩进方式。</h4><p>示例：如下例子不符合规范。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (...) &#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example_fun</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>应如下书写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example_fun</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-11：在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－-gt-），后不应加空格。"><a href="#1-11：在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－-gt-），后不应加空格。" class="headerlink" title="1-11：在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－&gt;），后不应加空格。"></a>1-11：在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－&gt;），后不应加空格。</h4><p>说明：采用这种松散方式编写代码的目的是使代码更加清晰。</p>
<p>由于留空格所产生的清晰性是相对的，所以，在已经非常清晰的语句中没有必要再留空格，如果语句已足够清晰则括号内侧(即左括号后面和右括号前面)不需要加空格，多重括号间不必加空格，因为在C/C++语言中括号已经是最清晰的标志了。</p>
<p>在长语句中，如果需要加的空格非常多，那么应该保持整体清晰，而在局部不加空格。给操作符留空格时不要连续留两个以上空格。 </p>
<p>示例：</p>
<p>(1) 逗号、分号只在后面加空格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c;</span><br></pre></td></tr></table></figure>
<p>(2)比较操作符, 赋值操作符”=”、 “+=”，算术操作符”+”、”%”，逻辑操作符”&amp;&amp;”、”&amp;”，位域操作符”&lt;&lt;”、”^”等双目操作符的前后加空格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current_time &gt;= MAX_TIME_VALUE)</span><br><span class="line">a = b + c;</span><br><span class="line">a *= <span class="number">2</span>;</span><br><span class="line">a = b ^ <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>(3)”!”、”~”、”++”、”–”、”&amp;”（地址运算符）等单目操作符前后不加空格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="string">'a'</span>;        <span class="comment">// 内容操作""与内容之间</span></span><br><span class="line">flag = !isEmpty; <span class="comment">// 非操作"!"与内容之间</span></span><br><span class="line">p = &amp;mem;        <span class="comment">// 地址操作"&amp;" 与内容之间</span></span><br><span class="line">i++;             <span class="comment">// "++","--"与内容之间</span></span><br></pre></td></tr></table></figure>
<p>(4)”-&gt;”、”.”前后不加空格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;id = pid;     <span class="comment">// "-&gt;"指针前后不加空格</span></span><br></pre></td></tr></table></figure>
<p>(5) if、for、while、switch等与后面的括号间应加空格，使if等关键字更为突出、明显。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt;= b &amp;&amp; c &gt; d)</span><br></pre></td></tr></table></figure>
<h4 id="½1-1：一行程序以小于80字符为宜，不要写得过长。"><a href="#½1-1：一行程序以小于80字符为宜，不要写得过长。" class="headerlink" title="½1-1：一行程序以小于80字符为宜，不要写得过长。"></a>½1-1：一行程序以小于80字符为宜，不要写得过长。</h4><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2 注释"></a>2 注释</h3><h4 id="2-1：一般情况下，源程序有效注释量必须在20％以上。"><a href="#2-1：一般情况下，源程序有效注释量必须在20％以上。" class="headerlink" title="2-1：一般情况下，源程序有效注释量必须在20％以上。"></a>2-1：一般情况下，源程序有效注释量必须在20％以上。</h4><p>说明：注释的原则是有助于对程序的阅读理解，在该加的地方都加了，注释不宜太多也不能太少，注释语言必须准确、易懂、简洁。</p>
<h4 id="2-2：说明性文件（如头文件-h文件、-inc文件、-def文件、编译说明文件-cfg等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。"><a href="#2-2：说明性文件（如头文件-h文件、-inc文件、-def文件、编译说明文件-cfg等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。" class="headerlink" title="2-2：说明性文件（如头文件.h文件、.inc文件、.def文件、编译说明文件.cfg等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。"></a>2-2：说明性文件（如头文件.h文件、.inc文件、.def文件、编译说明文件.cfg等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。</h4><p>示例：下面这段头文件的头注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Copyright (C), 1988-1999, Huawei Tech. Co., Ltd.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  File name:      // 文件名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Author:       Version:        Date: // 作者、版本及完成日期</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Description:    // 用于详细说明此程序文件完成的主要功能，与其他模块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  // 或函数的接口，输出值、取值范围、含义及参数间的控</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  // 制、顺序、独立或依赖等关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Others:         // 其它内容的说明</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Function List:  // 主要函数列表，每条记录应包括函数名及功能简要说明</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1. ....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  History:        // 修改历史记录列表，每条修改记录应包括修改日期、修改</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  // 者及修改内容简述 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1. Date:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Author:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Modification:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    2. ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3：源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的-功能、主要函数及其功能、修改日志等。"><a href="#2-3：源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的-功能、主要函数及其功能、修改日志等。" class="headerlink" title="2-3：源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的/功能、主要函数及其功能、修改日志等。"></a>2-3：源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的/功能、主要函数及其功能、修改日志等。</h4><p>示例：下面这段源文件的头注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Copyright (C), 1988-1999, Huawei Tech. Co., Ltd.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  FileName: test.cpp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Author:        Version :          Date:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Description:     // 模块描述     </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Version:         // 版本信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Function List:   // 主要函数及其功能</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1. -------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  History:         // 历史修改记录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;author&gt;  &lt;time&gt;   &lt;version &gt;   &lt;desc&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      David    96/10/12     1.0     build this moudle </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br></pre></td></tr></table></figure>
<p>说明：Description一项描述本文件的内容、功能、内部各部分之间的关系及本文件与其它文件关系等。History是修改历史记录列表，每条修改记录应包括修改日期、修改者及修改内容简述。</p>
<h4 id="2-4：函数头部应进行注释，列出：函数的目的-功能、输入参数、输出参数、返回值、调用关系（函数、表）等。"><a href="#2-4：函数头部应进行注释，列出：函数的目的-功能、输入参数、输出参数、返回值、调用关系（函数、表）等。" class="headerlink" title="2-4：函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。"></a>2-4：函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。</h4><p>示例：下面这段函数的注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Function:       // 函数名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Description:    // 函数功能、性能等的描述</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Calls:          // 被本函数调用的函数清单</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Called By:      // 调用本函数的函数清单</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Table Accessed: // 被访问的表（此项仅对于牵扯到数据库操作的程序）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Table Updated:  // 被修改的表（此项仅对于牵扯到数据库操作的程序）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Input:          // 输入参数说明，包括每个参数的作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  // 用、取值说明及参数间关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Output:         // 对输出参数的说明。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Return:         // 函数返回值的说明</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Others:         // 其它说明</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*************************************************/</span></span><br></pre></td></tr></table></figure>
<h4 id="2-5：边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。"><a href="#2-5：边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。" class="headerlink" title="2-5：边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。"></a>2-5：边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。</h4><h4 id="2-6：注释的内容要清楚、明了，含义准确，防止注释二义性。"><a href="#2-6：注释的内容要清楚、明了，含义准确，防止注释二义性。" class="headerlink" title="2-6：注释的内容要清楚、明了，含义准确，防止注释二义性。"></a>2-6：注释的内容要清楚、明了，含义准确，防止注释二义性。</h4><p>说明：错误的注释不但无益反而有害。</p>
<h4 id="2-7：避免在注释中使用缩写，特别是非常用缩写。"><a href="#2-7：避免在注释中使用缩写，特别是非常用缩写。" class="headerlink" title="2-7：避免在注释中使用缩写，特别是非常用缩写。"></a>2-7：避免在注释中使用缩写，特别是非常用缩写。</h4><p>说明：在使用缩写时或之前，应对缩写进行必要的说明。</p>
<h4 id="2-8：注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。"><a href="#2-8：注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。" class="headerlink" title="2-8：注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。"></a>2-8：注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。</h4><p>示例：如下例子不符合规范。</p>
<p>例1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get replicate sub system index and net indicator */</span> </span><br><span class="line"></span><br><span class="line">repssn_ind = ssn_data[index].repssn_index;</span><br><span class="line">repssn_ni = ssn_data[index].ni;</span><br></pre></td></tr></table></figure>
<p>例2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repssn_ind = ssn_data[index].repssn_index;</span><br><span class="line">repssn_ni = ssn_data[index].ni;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get replicate sub system index and net indicator */</span></span><br></pre></td></tr></table></figure>
<p>应如下书写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get replicate sub system index and net indicator */</span></span><br><span class="line">repssn_ind = ssn_data[index].repssn_index;</span><br><span class="line">repssn_ni = ssn_data[index].ni;</span><br></pre></td></tr></table></figure>
<h4 id="2-9：对于所有有物理含义的变量、常量，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其物理含义。变量、常量、宏的注释应放在其上方相邻位置或右方。"><a href="#2-9：对于所有有物理含义的变量、常量，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其物理含义。变量、常量、宏的注释应放在其上方相邻位置或右方。" class="headerlink" title="2-9：对于所有有物理含义的变量、常量，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其物理含义。变量、常量、宏的注释应放在其上方相邻位置或右方。"></a>2-9：对于所有有物理含义的变量、常量，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其物理含义。变量、常量、宏的注释应放在其上方相邻位置或右方。</h4><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* active statistic task number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ACT_TASK_NUMBER 1000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ACT_TASK_NUMBER 1000 <span class="comment">/* active statistic task number */</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-10：数据结构声明-包括数组、结构、类、枚举等-，如果其命名不是充分自注释的，必须加以注释。对数据结构的注释应放在其上方相邻位置，不可放在下面；对结构中的每个域的注释放在此域的右方。"><a href="#2-10：数据结构声明-包括数组、结构、类、枚举等-，如果其命名不是充分自注释的，必须加以注释。对数据结构的注释应放在其上方相邻位置，不可放在下面；对结构中的每个域的注释放在此域的右方。" class="headerlink" title="2-10：数据结构声明(包括数组、结构、类、枚举等)，如果其命名不是充分自注释的，必须加以注释。对数据结构的注释应放在其上方相邻位置，不可放在下面；对结构中的每个域的注释放在此域的右方。"></a>2-10：数据结构声明(包括数组、结构、类、枚举等)，如果其命名不是充分自注释的，必须加以注释。对数据结构的注释应放在其上方相邻位置，不可放在下面；对结构中的每个域的注释放在此域的右方。</h4><p>示例：可按如下形式说明枚举/数据/联合结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sccp interface with sccp user primitive message name */</span></span><br><span class="line"><span class="keyword">enum</span>  SCCP_USER_PRIMITIVE</span><br><span class="line">&#123;</span><br><span class="line">    N_UNITDATA_IND, <span class="comment">/* sccp notify sccp user unit data come */</span></span><br><span class="line">    N_NOTICE_IND,   <span class="comment">/* sccp notify user the No.7 network can not */</span></span><br><span class="line">                    <span class="comment">/* transmission this message */</span></span><br><span class="line">    N_UNITDATA_REQ, <span class="comment">/* sccp user's unit data transmission request*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-11：全局变量要有较详细的注释，包括对其功能、取值范围、哪些函数或过程存取它以及存取时注意事项等的说明。"><a href="#2-11：全局变量要有较详细的注释，包括对其功能、取值范围、哪些函数或过程存取它以及存取时注意事项等的说明。" class="headerlink" title="2-11：全局变量要有较详细的注释，包括对其功能、取值范围、哪些函数或过程存取它以及存取时注意事项等的说明。"></a>2-11：全局变量要有较详细的注释，包括对其功能、取值范围、哪些函数或过程存取它以及存取时注意事项等的说明。</h4><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The ErrorCode when SCCP translate */</span></span><br><span class="line"><span class="comment">/* Global Title failure, as follows */</span>      <span class="comment">// 变量作用、含义</span></span><br><span class="line"><span class="comment">/* 0 － SUCCESS   1 － GT Table error */</span></span><br><span class="line"><span class="comment">/* 2 － GT error  Others － no use  */</span>       <span class="comment">// 变量取值范围</span></span><br><span class="line"><span class="comment">/* only  function  SCCPTranslate() in */</span></span><br><span class="line"><span class="comment">/* this modual can modify it,  and  other */</span></span><br><span class="line"><span class="comment">/* module can visit it through call */</span></span><br><span class="line"><span class="comment">/* the  function GetGTTransErrorCode() */</span>    <span class="comment">// 使用方法</span></span><br><span class="line">BYTE g_GTTranErrorCode;</span><br></pre></td></tr></table></figure>
<h4 id="2-12：注释与所描述内容进行同样的缩排。"><a href="#2-12：注释与所描述内容进行同样的缩排。" class="headerlink" title="2-12：注释与所描述内容进行同样的缩排。"></a>2-12：注释与所描述内容进行同样的缩排。</h4><p>说明：可使程序排版整齐，并方便注释的阅读与理解。</p>
<p>示例：如下例子，排版不整齐，阅读稍感不方便。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example_fun</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* code one comments */</span></span><br><span class="line">    CodeBlock One </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* code two comments */</span></span><br><span class="line">    CodeBlock Two</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为如下布局。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example_fun</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* code one comments */</span></span><br><span class="line">    CodeBlock One</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* code two comments */</span></span><br><span class="line">    CodeBlock Two</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-13：将注释与其上面的代码用空行隔开。"><a href="#2-13：将注释与其上面的代码用空行隔开。" class="headerlink" title="2-13：将注释与其上面的代码用空行隔开。"></a>2-13：将注释与其上面的代码用空行隔开。</h4><p>示例：如下例子，显得代码过于紧凑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* code one comments */</span></span><br><span class="line">program code one</span><br><span class="line"><span class="comment">/* code two comments */</span></span><br><span class="line">program code two</span><br></pre></td></tr></table></figure>
<p>应如下书写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* code one comments */</span></span><br><span class="line">program code one</span><br><span class="line"></span><br><span class="line"><span class="comment">/* code two comments */</span></span><br><span class="line">program code two</span><br></pre></td></tr></table></figure>
<h4 id="2-14：对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。"><a href="#2-14：对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。" class="headerlink" title="2-14：对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。"></a>2-14：对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。</h4><p>说明：这些语句往往是程序实现某一特定功能的关键，对于维护人员来说，良好的注释帮助更好的理解程序，有时甚至优于看设计文档。</p>
<h4 id="2-15：对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。"><a href="#2-15：对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。" class="headerlink" title="2-15：对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。"></a>2-15：对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。</h4><p>说明：这样比较清楚程序编写者的意图，有效防止无故遗漏break语句。</p>
<p>示例（注意斜体加粗部分）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CMD_UP:  </span><br><span class="line">    ProcessUp();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CMD_DOWN:</span><br><span class="line">    ProcessDown();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CMD_FWD: </span><br><span class="line">    ProcessFwd();</span><br><span class="line">	<span class="keyword">if</span> (...)</span><br><span class="line">	&#123;</span><br><span class="line">    	...</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	ProcessCFW_B();   <span class="comment">// now jump into case CMD_A</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CMD_A:   </span><br><span class="line">    ProcessA();   </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CMD_B:   </span><br><span class="line">    ProcessB();   </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CMD_C:   </span><br><span class="line">    ProcessC();   </span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CMD_D:   </span><br><span class="line">    ProcessD();   </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="½2-1：避免在一行代码或表达式的中间插入注释。"><a href="#½2-1：避免在一行代码或表达式的中间插入注释。" class="headerlink" title="½2-1：避免在一行代码或表达式的中间插入注释。"></a>½2-1：避免在一行代码或表达式的中间插入注释。</h4><p>说明：除非必要，不应在代码或表达中间插入注释，否则容易使代码可理解性变差。</p>
<h4 id="½2-2：通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。"><a href="#½2-2：通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。" class="headerlink" title="½2-2：通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。"></a>½2-2：通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。</h4><p>说明：清晰准确的函数、变量等的命名，可增加代码可读性，并减少不必要的注释。</p>
<h4 id="½2-3：在代码的功能、意图层次上进行注释，提供有用、额外的信息。"><a href="#½2-3：在代码的功能、意图层次上进行注释，提供有用、额外的信息。" class="headerlink" title="½2-3：在代码的功能、意图层次上进行注释，提供有用、额外的信息。"></a>½2-3：在代码的功能、意图层次上进行注释，提供有用、额外的信息。</h4><p>说明：注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。</p>
<p>示例：如下注释意义不大。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if receive_flag is TRUE */</span></span><br><span class="line"><span class="keyword">if</span> (receive_flag)</span><br></pre></td></tr></table></figure>
<p>而如下的注释则给出了额外有用的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if mtp receive a message from links */</span></span><br><span class="line"><span class="keyword">if</span> (receive_flag)</span><br></pre></td></tr></table></figure>
<h4 id="½2-4：在程序块的结束行右方加注释标记，以表明某程序块的结束。"><a href="#½2-4：在程序块的结束行右方加注释标记，以表明某程序块的结束。" class="headerlink" title="½2-4：在程序块的结束行右方加注释标记，以表明某程序块的结束。"></a>½2-4：在程序块的结束行右方加注释标记，以表明某程序块的结束。</h4><p>说明：当代码段较长，特别是多重嵌套时，这样做可以使代码更清晰，更便于阅读。</p>
<p>示例：参见如下例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// program code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; MAX_INDEX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// program code</span></span><br><span class="line">    &#125; <span class="comment">/* end of while (index &lt; MAX_INDEX) */</span> <span class="comment">// 指明该条while语句结束</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">/* end of  if (...)*/</span> <span class="comment">// 指明是哪条if语句结束</span></span><br></pre></td></tr></table></figure>
<h4 id="½2-5：注释格式尽量统一，建议使用“-……-”。"><a href="#½2-5：注释格式尽量统一，建议使用“-……-”。" class="headerlink" title="½2-5：注释格式尽量统一，建议使用“/ …… /”。"></a>½2-5：注释格式尽量统一，建议使用“/<em> …… </em>/”。</h4><h4 id="½2-6：注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。"><a href="#½2-6：注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。" class="headerlink" title="½2-6：注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。"></a>½2-6：注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。</h4><p>说明：注释语言不统一，影响程序易读性和外观排版，出于对维护人员的考虑，建议使用中文。</p>
<h3 id="3-标识符命名"><a href="#3-标识符命名" class="headerlink" title="3 标识符命名"></a>3 标识符命名</h3><h4 id="3-1：标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。"><a href="#3-1：标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。" class="headerlink" title="3-1：标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。"></a>3-1：标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。</h4><p>说明：较短的单词可通过去掉“元音”形成缩写；较长的单词可取单词的头几个字母形成缩写；一些单词有大家公认的缩写。</p>
<p>示例：如下单词的缩写能够被大家基本认可。</p>
<blockquote>
<p>temp 可缩写为  tmp  ;</p>
<p>flag 可缩写为  flg  ;</p>
<p>statistic 可缩写为  stat ;</p>
<p>increment 可缩写为  inc  ;</p>
<p>message 可缩写为  msg  ;</p>
</blockquote>
<h4 id="3-2：命名中若使用特殊约定或缩写，则要有注释说明。"><a href="#3-2：命名中若使用特殊约定或缩写，则要有注释说明。" class="headerlink" title="3-2：命名中若使用特殊约定或缩写，则要有注释说明。"></a>3-2：命名中若使用特殊约定或缩写，则要有注释说明。</h4><p>说明：应该在源文件的开始之处，对文件中所使用的缩写或约定，特别是特殊的缩写，进行必要的注释说明。</p>
<h4 id="3-3：自己特有的命名风格，要自始至终保持一致，不可来回变化。"><a href="#3-3：自己特有的命名风格，要自始至终保持一致，不可来回变化。" class="headerlink" title="3-3：自己特有的命名风格，要自始至终保持一致，不可来回变化。"></a>3-3：自己特有的命名风格，要自始至终保持一致，不可来回变化。</h4><p>说明：个人的命名风格，在符合所在项目组或产品组的命名规则的前提下，才可使用。（即命名规则中没有规定到的地方才可有个人命名风格）。</p>
<h4 id="3-4：对于变量命名，禁止取单个字符（如i、j、k…），建议除了要有具体含义外，还能表明其变量类型、数据类型等，但i、j、k作局部循环变量是允许的。"><a href="#3-4：对于变量命名，禁止取单个字符（如i、j、k…），建议除了要有具体含义外，还能表明其变量类型、数据类型等，但i、j、k作局部循环变量是允许的。" class="headerlink" title="3-4：对于变量命名，禁止取单个字符（如i、j、k…），建议除了要有具体含义外，还能表明其变量类型、数据类型等，但i、j、k作局部循环变量是允许的。"></a>3-4：对于变量命名，禁止取单个字符（如i、j、k…），建议除了要有具体含义外，还能表明其变量类型、数据类型等，但i、j、k作局部循环变量是允许的。</h4><p>说明：变量，尤其是局部变量，如果用单个字符表示，很容易敲错（如i写成j），而编译时又检查不出来，有可能为了这个小小的错误而花费大量的查错时间。</p>
<p>示例：下面所示的局部变量名的定义方法可以借鉴。</p>
<blockquote>
<p>int liv_Width</p>
<p>其变量名解释如下：</p>
<p>​       l      局部变量（Local）  （其它：g    全局变量（Global）…）</p>
<p>​       i      数据类型（Interger）</p>
<p>​       v      变量（Variable）   （其它：c    常量（Const）…）</p>
<p>​       Width  变量含义</p>
</blockquote>
<p>这样可以防止局部变量与全局变量重名。</p>
<h4 id="3-5：命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用UNIX的全小写加下划线的风格或大小写混排的方式，不要使用大小写与下划线混排的方式，用作特殊标识如标识成员变量或全局变量的m-和g-，其后加上大小写混排的方式是允许的。"><a href="#3-5：命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用UNIX的全小写加下划线的风格或大小写混排的方式，不要使用大小写与下划线混排的方式，用作特殊标识如标识成员变量或全局变量的m-和g-，其后加上大小写混排的方式是允许的。" class="headerlink" title="3-5：命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用UNIX的全小写加下划线的风格或大小写混排的方式，不要使用大小写与下划线混排的方式，用作特殊标识如标识成员变量或全局变量的m_和g_，其后加上大小写混排的方式是允许的。"></a>3-5：命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用UNIX的全小写加下划线的风格或大小写混排的方式，不要使用大小写与下划线混排的方式，用作特殊标识如标识成员变量或全局变量的m_和g_，其后加上大小写混排的方式是允许的。</h4><p>示例： Add_User不允许，add_user、AddUser、m_AddUser允许。</p>
<h4 id="½3-1：除非必要，不要用数字或较奇怪的字符来定义标识符。"><a href="#½3-1：除非必要，不要用数字或较奇怪的字符来定义标识符。" class="headerlink" title="½3-1：除非必要，不要用数字或较奇怪的字符来定义标识符。"></a>½3-1：除非必要，不要用数字或较奇怪的字符来定义标识符。</h4><p>示例：如下命名，使人产生疑惑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EXAMPLE_0_TEST_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EXAMPLE_1_TEST_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_sls00</span><span class="params">( BYTE sls )</span></span>;</span><br></pre></td></tr></table></figure>
<p>应改为有意义的单词命名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EXAMPLE_UNIT_TEST_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EXAMPLE_ASSERT_TEST_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_udt_msg_sls</span><span class="params">( BYTE sls )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="½3-2：在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突。"><a href="#½3-2：在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突。" class="headerlink" title="½3-2：在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突。"></a>½3-2：在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突。</h4><p>说明：对接口部分的标识符应该有更严格限制，防止冲突。如可规定接口部分的变量与常量之前加上“模块”标识等。</p>
<h4 id="½3-3：用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。"><a href="#½3-3：用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。" class="headerlink" title="½3-3：用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。"></a>½3-3：用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。</h4><p>说明：下面是一些在软件中常用的反义词组。</p>
<blockquote>
<p>add / remove       begin / end        create / destroy</p>
<p>insert / delete    first / last       get / release</p>
<p>increment / decrement                 put / get</p>
<p>add / delete       lock / unlock      open / close</p>
<p>min / max          old / new          start / stop</p>
<p>next / previous    source / target    show / hide</p>
<p>send / receive     source / destination</p>
<p>cut / paste        up / down</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  min_sum;</span><br><span class="line"><span class="keyword">int</span>  max_sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">add_user</span><span class="params">( BYTE *user_name )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">delete_user</span><span class="params">( BYTE *user_name )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="½3-4：除了编译开关-头文件等特殊应用，应避免使用-EXAMPLE-TEST-之类以下划线开始和结尾的定义。"><a href="#½3-4：除了编译开关-头文件等特殊应用，应避免使用-EXAMPLE-TEST-之类以下划线开始和结尾的定义。" class="headerlink" title="½3-4：除了编译开关/头文件等特殊应用，应避免使用_EXAMPLE_TEST_之类以下划线开始和结尾的定义。"></a>½3-4：除了编译开关/头文件等特殊应用，应避免使用_EXAMPLE_TEST_之类以下划线开始和结尾的定义。</h4><h3 id="4-可读性"><a href="#4-可读性" class="headerlink" title="4 可读性"></a>4 可读性</h3><h4 id="4-1：注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级。"><a href="#4-1：注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级。" class="headerlink" title="4-1：注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级。"></a>4-1：注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级。</h4><p>说明：防止阅读程序时产生误解，防止因默认的优先级与设计思想不符而导致程序出错。</p>
<p>示例：下列语句中的表达式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">word = (high &lt;&lt; <span class="number">8</span>) | low     (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> ((a | b) &amp;&amp; (a &amp; c))      (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> ((a | b) &lt; (c &amp; d))       (<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>如果书写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high &lt;&lt; 8 | low</span><br><span class="line">a | b &amp;&amp; a &amp; c</span><br><span class="line">a | b &lt; c &amp; d</span><br></pre></td></tr></table></figure>
<p>由于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">high &lt;&lt; <span class="number">8</span> | low = ( high &lt;&lt; <span class="number">8</span>) | low,</span><br><span class="line">a | b &amp;&amp; a &amp; c = (a | b) &amp;&amp; (a &amp; c)，</span><br></pre></td></tr></table></figure>
<p>(1)(2)不会出错，但语句不易理解；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a | b &lt; c &amp; d = a | （b &lt; c） &amp; d</span><br></pre></td></tr></table></figure>
<p>(3)造成了判断条件出错。</p>
<h4 id="4-2：避免使用不易理解的数字，用有意义的标识来替代。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。"><a href="#4-2：避免使用不易理解的数字，用有意义的标识来替代。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。" class="headerlink" title="4-2：避免使用不易理解的数字，用有意义的标识来替代。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。"></a>4-2：避免使用不易理解的数字，用有意义的标识来替代。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。</h4><p>示例：如下的程序可读性差。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Trunk[index].trunk_state == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Trunk[index].trunk_state = <span class="number">1</span>;</span><br><span class="line">    ...  <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为如下形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUNK_IDLE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUNK_BUSY 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Trunk[index].trunk_state == TRUNK_IDLE)</span><br><span class="line">&#123;</span><br><span class="line">    Trunk[index].trunk_state = TRUNK_BUSY;</span><br><span class="line">    ...  <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="½4-1：源程序中关系较为紧密的代码应尽可能相邻。"><a href="#½4-1：源程序中关系较为紧密的代码应尽可能相邻。" class="headerlink" title="½4-1：源程序中关系较为紧密的代码应尽可能相邻。"></a>½4-1：源程序中关系较为紧密的代码应尽可能相邻。</h4><p>说明：便于程序阅读和查找。</p>
<p>示例：以下代码布局不太合理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rect.length = <span class="number">10</span>;</span><br><span class="line">char_poi = str;</span><br><span class="line">rect.width = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>若按如下形式书写，可能更清晰一些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rect.length = <span class="number">10</span>;</span><br><span class="line">rect.width = <span class="number">5</span>; <span class="comment">// 矩形的长与宽关系较密切，放在一起。</span></span><br><span class="line">char_poi = str;</span><br></pre></td></tr></table></figure>
<h4 id="½4-2：不要使用难懂的技巧性很高的语句，除非很有必要时。"><a href="#½4-2：不要使用难懂的技巧性很高的语句，除非很有必要时。" class="headerlink" title="½4-2：不要使用难懂的技巧性很高的语句，除非很有必要时。"></a>½4-2：不要使用难懂的技巧性很高的语句，除非很有必要时。</h4><p>说明：高技巧语句不等于高效率的程序，实际上程序的效率关键在于算法。</p>
<p>示例：如下表达式，考虑不周就可能出问题，也较难理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* stat_poi ++ += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">* ++ stat_poi += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>应分别改为如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*stat_poi += <span class="number">1</span>;</span><br><span class="line">stat_poi++;     <span class="comment">// 此二语句功能相当于“ * stat_poi ++ += 1; ”</span></span><br><span class="line"></span><br><span class="line">++ stat_poi;</span><br><span class="line">*stat_poi += <span class="number">1</span>; <span class="comment">// 此二语句功能相当于“ * ++ stat_poi += 1; ”</span></span><br></pre></td></tr></table></figure>
<h3 id="5-变量、结构"><a href="#5-变量、结构" class="headerlink" title="5 变量、结构"></a>5 变量、结构</h3><h4 id="5-1：去掉没必要的公共变量。"><a href="#5-1：去掉没必要的公共变量。" class="headerlink" title="5-1：去掉没必要的公共变量。"></a>5-1：去掉没必要的公共变量。</h4><p>说明：公共变量是增大模块间耦合的原因之一，故应减少没必要的公共变量以降低模块间的耦合度。</p>
<h4 id="5-2：仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系。"><a href="#5-2：仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系。" class="headerlink" title="5-2：仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系。"></a>5-2：仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系。</h4><p>说明：在对变量声明的同时，应对其含义、作用及取值范围进行注释说明，同时若有必要还应说明与其它变量的关系。</p>
<h4 id="5-3：明确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。"><a href="#5-3：明确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。" class="headerlink" title="5-3：明确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。"></a>5-3：明确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。</h4><p>说明：明确过程操作变量的关系后，将有利于程序的进一步优化、单元测试、系统联调以及代码维护等。这种关系的说明可在注释或文档中描述。</p>
<p>示例：在源文件中，可按如下注释形式说明。</p>
<blockquote>
<p>RELATION    System_Init    Input_Rec    Print_Rec   Stat_Score</p>
<p>Student     Create         Modify       Access      Access</p>
<p>Score       Create         Modify       Access      Access, Modify</p>
<p>注：RELATION为操作关系；System_Init、Input_Rec、Print_Rec、Stat_Score为四个不同的函数；Student、Score为两个全局变量；Create表示创建，Modify表示修改，Access表示访问。</p>
<p>其中，函数Input_Rec、Stat_Score都可修改变量Score，故此变量将引起函数间较大的耦合，并可能增加代码测试、维护的难度。</p>
</blockquote>
<h4 id="5-4：当向公共变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。"><a href="#5-4：当向公共变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。" class="headerlink" title="5-4：当向公共变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。"></a>5-4：当向公共变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。</h4><p>说明：对公共变量赋值时，若有必要应进行合法性检查，以提高代码的可靠性、稳定性。</p>
<h4 id="5-5：防止局部变量与公共变量同名。"><a href="#5-5：防止局部变量与公共变量同名。" class="headerlink" title="5-5：防止局部变量与公共变量同名。"></a>5-5：防止局部变量与公共变量同名。</h4><p>说明：若使用了较好的命名规则，那么此问题可自动消除。</p>
<h4 id="5-6：严禁使用未经初始化的变量作为右值。"><a href="#5-6：严禁使用未经初始化的变量作为右值。" class="headerlink" title="5-6：严禁使用未经初始化的变量作为右值。"></a>5-6：严禁使用未经初始化的变量作为右值。</h4><p>说明：特别是在C/C++中引用未经赋值的指针，经常会引起系统崩溃。</p>
<h4 id="½5-1：构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的公共变量，防止多个不同模块或函数都可以修改、创建同一公共变量的现象。"><a href="#½5-1：构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的公共变量，防止多个不同模块或函数都可以修改、创建同一公共变量的现象。" class="headerlink" title="½5-1：构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的公共变量，防止多个不同模块或函数都可以修改、创建同一公共变量的现象。"></a>½5-1：构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的公共变量，防止多个不同模块或函数都可以修改、创建同一公共变量的现象。</h4><p>说明：降低公共变量耦合度。</p>
<h4 id="½5-2：使用严格形式定义的、可移植的数据类型，尽量不要使用与具体硬件或软件环境关系密切的变量。"><a href="#½5-2：使用严格形式定义的、可移植的数据类型，尽量不要使用与具体硬件或软件环境关系密切的变量。" class="headerlink" title="½5-2：使用严格形式定义的、可移植的数据类型，尽量不要使用与具体硬件或软件环境关系密切的变量。"></a>½5-2：使用严格形式定义的、可移植的数据类型，尽量不要使用与具体硬件或软件环境关系密切的变量。</h4><p>说明：使用标准的数据类型，有利于程序的移植。</p>
<p>示例：如下例子（在DOS下BC3.1环境中），在移植时可能产生问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> index; <span class="comment">// 寄存器变量</span></span><br><span class="line"></span><br><span class="line">    _AX = <span class="number">0x4000</span>; <span class="comment">// _AX是BC3.1提供的寄存器“伪变量”</span></span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="½5-3：结构的功能要单一，是针对一种事务的抽象。"><a href="#½5-3：结构的功能要单一，是针对一种事务的抽象。" class="headerlink" title="½5-3：结构的功能要单一，是针对一种事务的抽象。"></a>½5-3：结构的功能要单一，是针对一种事务的抽象。</h4><p>说明：设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构中。</p>
<p>示例：如下结构不太清晰、合理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> name[<span class="number">8</span>]; <span class="comment">/* student's name */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> age;     <span class="comment">/* student's age */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sex;     <span class="comment">/* student's sex, as follows */</span></span><br><span class="line">                           <span class="comment">/* 0 - FEMALE; 1 - MALE */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span></span><br><span class="line">           teacher_name[<span class="number">8</span>]; <span class="comment">/* the student teacher's name */</span></span><br><span class="line"></span><br><span class="line">    unisgned <span class="keyword">char</span></span><br><span class="line">           teacher_sex;     <span class="comment">/* his teacher sex */</span></span><br><span class="line">&#125; STUDENT;</span><br></pre></td></tr></table></figure>
<p>若改为如下，可能更合理些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TEACHER_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> name[<span class="number">8</span>]; <span class="comment">/* teacher name */</span></span><br><span class="line">    unisgned <span class="keyword">char</span> sex;     <span class="comment">/* teacher sex, as follows */</span></span><br><span class="line">                           <span class="comment">/* 0 - FEMALE; 1 - MALE */</span></span><br><span class="line">&#125; TEACHER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> name[<span class="number">8</span>];     <span class="comment">/* student's name */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> age;         <span class="comment">/* student's age */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sex;         <span class="comment">/* student's sex, as follows */</span></span><br><span class="line">                               <span class="comment">/* 0 - FEMALE; 1 - MALE */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  teacher_ind; <span class="comment">/* his teacher index */</span></span><br><span class="line">&#125; STUDENT;</span><br></pre></td></tr></table></figure>
<h4 id="½5-4：不要设计面面俱到、非常灵活的数据结构。"><a href="#½5-4：不要设计面面俱到、非常灵活的数据结构。" class="headerlink" title="½5-4：不要设计面面俱到、非常灵活的数据结构。"></a>½5-4：不要设计面面俱到、非常灵活的数据结构。</h4><p>说明：面面俱到、灵活的数据结构反而容易引起误解和操作困难。</p>
<h4 id="½5-5：不同结构间的关系不要过于复杂。"><a href="#½5-5：不同结构间的关系不要过于复杂。" class="headerlink" title="½5-5：不同结构间的关系不要过于复杂。"></a>½5-5：不同结构间的关系不要过于复杂。</h4><p>说明：若两个结构间关系较复杂、密切，那么应合为一个结构。</p>
<p>示例：如下两个结构的构造不合理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PERSON_ONE_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> addr[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> city[<span class="number">15</span>];</span><br><span class="line">&#125; PERSON_ONE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PERSON_TWO_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> age;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tel;</span><br><span class="line">&#125; PERSON_TWO;</span><br></pre></td></tr></table></figure>
<p>由于两个结构都是描述同一事物的，那么不如合成一个结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PERSON_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> age;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> addr[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> city[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tel;</span><br><span class="line">&#125; PERSON;</span><br></pre></td></tr></table></figure>
<h4 id="½5-6：结构中元素的个数应适中。若结构中元素个数过多可考虑依据某种原则把元素组成不同的子结构，以减少原结构中元素的个数。"><a href="#½5-6：结构中元素的个数应适中。若结构中元素个数过多可考虑依据某种原则把元素组成不同的子结构，以减少原结构中元素的个数。" class="headerlink" title="½5-6：结构中元素的个数应适中。若结构中元素个数过多可考虑依据某种原则把元素组成不同的子结构，以减少原结构中元素的个数。"></a>½5-6：结构中元素的个数应适中。若结构中元素个数过多可考虑依据某种原则把元素组成不同的子结构，以减少原结构中元素的个数。</h4><p>说明：增加结构的可理解性、可操作性和可维护性。</p>
<p>示例：假如认为如上的_PERSON结构元素过多，那么可如下对之划分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PERSON_BASE_INFO_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> age;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sex;</span><br><span class="line">&#125; PERSON_BASE_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PERSON_ADDRESS_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> addr[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> city[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> tel;</span><br><span class="line">&#125; PERSON_ADDRESS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PERSON_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PERSON_BASE_INFO person_base;</span><br><span class="line">    PERSON_ADDRESS person_addr;</span><br><span class="line">&#125; PERSON;</span><br></pre></td></tr></table></figure>
<h4 id="½5-7：仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象。"><a href="#½5-7：仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象。" class="headerlink" title="½5-7：仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象。"></a>½5-7：仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象。</h4><p>说明：合理排列结构中元素顺序，可节省空间并增加可理解性。</p>
<p>示例：如下结构中的位域排列，将占较大空间，可读性也稍差。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EXAMPLE_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> valid: <span class="number">1</span>;</span><br><span class="line">    PERSON person;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> set_flg: <span class="number">1</span>;</span><br><span class="line">&#125; EXAMPLE;</span><br></pre></td></tr></table></figure>
<p>若改成如下形式，不仅可节省1字节空间，可读性也变好了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EXAMPLE_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> valid: <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> set_flg: <span class="number">1</span>;</span><br><span class="line">    PERSON person ;</span><br><span class="line">&#125; EXAMPLE;</span><br></pre></td></tr></table></figure>
<h4 id="½5-8：结构的设计要尽量考虑向前兼容和以后的版本升级，并为某些未来可能的应用保留余地（如预留一些空间等）。"><a href="#½5-8：结构的设计要尽量考虑向前兼容和以后的版本升级，并为某些未来可能的应用保留余地（如预留一些空间等）。" class="headerlink" title="½5-8：结构的设计要尽量考虑向前兼容和以后的版本升级，并为某些未来可能的应用保留余地（如预留一些空间等）。"></a>½5-8：结构的设计要尽量考虑向前兼容和以后的版本升级，并为某些未来可能的应用保留余地（如预留一些空间等）。</h4><p>说明：软件向前兼容的特性，是软件产品是否成功的重要标志之一。如果要想使产品具有较好的前向兼容，那么在产品设计之初就应为以后版本升级保留一定余地，并且在产品升级时必须考虑前一版本的各种特性。</p>
<h4 id="½5-9：留心具体语言及编译器处理不同数据类型的原则及有关细节。"><a href="#½5-9：留心具体语言及编译器处理不同数据类型的原则及有关细节。" class="headerlink" title="½5-9：留心具体语言及编译器处理不同数据类型的原则及有关细节。"></a>½5-9：留心具体语言及编译器处理不同数据类型的原则及有关细节。</h4><p>说明：如在C语言中，static局部变量将在内存“数据区”中生成，而非static局部变量将在“堆栈”中生成。这些细节对程序质量的保证非常重要。</p>
<h4 id="½5-10：编程时，要注意数据类型的强制转换。"><a href="#½5-10：编程时，要注意数据类型的强制转换。" class="headerlink" title="½5-10：编程时，要注意数据类型的强制转换。"></a>½5-10：编程时，要注意数据类型的强制转换。</h4><p>说明：当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。</p>
<h4 id="½5-11：对编译系统默认的数据类型转换，也要有充分的认识。"><a href="#½5-11：对编译系统默认的数据类型转换，也要有充分的认识。" class="headerlink" title="½5-11：对编译系统默认的数据类型转换，也要有充分的认识。"></a>½5-11：对编译系统默认的数据类型转换，也要有充分的认识。</h4><p>示例：如下赋值，多数编译器不产生告警，但值的含义还是稍有变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> chr;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> exam;</span><br><span class="line"></span><br><span class="line">chr = <span class="number">-1</span>;</span><br><span class="line">exam = chr; <span class="comment">// 编译器不产生告警，此时exam为0xFFFF</span></span><br></pre></td></tr></table></figure>
<h4 id="½5-12：尽量减少没有必要的数据类型默认转换与强制转换。"><a href="#½5-12：尽量减少没有必要的数据类型默认转换与强制转换。" class="headerlink" title="½5-12：尽量减少没有必要的数据类型默认转换与强制转换。"></a>½5-12：尽量减少没有必要的数据类型默认转换与强制转换。</h4><h4 id="½5-13：合理地设计数据并使用自定义数据类型，避免数据间进行不必要的类型转换。"><a href="#½5-13：合理地设计数据并使用自定义数据类型，避免数据间进行不必要的类型转换。" class="headerlink" title="½5-13：合理地设计数据并使用自定义数据类型，避免数据间进行不必要的类型转换。"></a>½5-13：合理地设计数据并使用自定义数据类型，避免数据间进行不必要的类型转换。</h4><h4 id="½5-14：对自定义数据类型进行恰当命名，使它成为自描述性的，以提高代码可读性。注意其命名方式在同一产品中的统一。"><a href="#½5-14：对自定义数据类型进行恰当命名，使它成为自描述性的，以提高代码可读性。注意其命名方式在同一产品中的统一。" class="headerlink" title="½5-14：对自定义数据类型进行恰当命名，使它成为自描述性的，以提高代码可读性。注意其命名方式在同一产品中的统一。"></a>½5-14：对自定义数据类型进行恰当命名，使它成为自描述性的，以提高代码可读性。注意其命名方式在同一产品中的统一。</h4><p>说明：使用自定义类型，可以弥补编程语言提供类型少、信息量不足的缺点，并能使程序清晰、简洁。</p>
<p>示例：可参考如下方式声明自定义数据类型。</p>
<p>下面的声明可使数据类型的使用简洁、明了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>  BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> WORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>   DWORD;</span><br></pre></td></tr></table></figure>
<p>下面的声明可使数据类型具有更丰富的含义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> DISTANCE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> SCORE;</span><br></pre></td></tr></table></figure>
<h4 id="½5-15：当声明用于分布式环境或不同CPU间通信环境的数据结构时，必须考虑机器的字节顺序、使用的位域及字节对齐等问题-。"><a href="#½5-15：当声明用于分布式环境或不同CPU间通信环境的数据结构时，必须考虑机器的字节顺序、使用的位域及字节对齐等问题-。" class="headerlink" title="½5-15：当声明用于分布式环境或不同CPU间通信环境的数据结构时，必须考虑机器的字节顺序、使用的位域及字节对齐等问题 。"></a>½5-15：当声明用于分布式环境或不同CPU间通信环境的数据结构时，必须考虑机器的字节顺序、使用的位域及字节对齐等问题 。</h4><p>说明：比如Intel CPU与68360 CPU，在处理位域及整数时，其在内存存放的“顺序”正好相反。</p>
<p>示例：假如有如下短整数及结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> exam;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EXAM_BIT_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span>                       <span class="comment">/* Intel 68360 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> A1: <span class="number">1</span>; <span class="comment">/* bit  0      7   */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> A2: <span class="number">1</span>; <span class="comment">/* bit  1      6   */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> A3: <span class="number">1</span>; <span class="comment">/* bit  2      5   */</span></span><br><span class="line">&#125; EXAM_BIT;</span><br></pre></td></tr></table></figure>
<p>如下是Intel CPU生成短整数及位域的方式。</p>
<blockquote>
<p>内存： 0          1         2    …  （从低到高，以字节为单位）</p>
<p>exam  exam低字节  exam高字节</p>
<p>内存：        0 bit     1 bit      2 bit    …  （字节的各“位”）</p>
<p>EXAM_BIT     A1        A2         A3</p>
</blockquote>
<p>如下是68360 CPU生成短整数及位域的方式。</p>
<blockquote>
<p>内存： 0          1         2    …  （从低到高，以字节为单位）</p>
<p>exam  exam高字节  exam低字节</p>
<p>内存：        7 bit     6 bit      5 bit    …  （字节的各“位”）</p>
<p>EXAM_BIT     A1        A2         A3</p>
</blockquote>
<p>说明：在对齐方式下，CPU的运行效率要快得多。</p>
<p>示例：如下图，当一个long型数（如图中long1）在内存中的位置正好与内存的字边界对齐时，CPU存取这个数只需访问一次内存，而当一个long型数（如图中的long2）在内存中的位置跨越了字边界时，CPU存取这个数就需要多次访问内存，如i960cx访问这样的数需读内存三次（一个BYTE、一个SHORT、一个BYTE，由CPU的微代码执行，对软件透明），所有对齐方式下CPU的运行效率明显快多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>       <span class="number">8</span>       <span class="number">16</span>      <span class="number">24</span>      <span class="number">32</span></span><br><span class="line">------- ------- ------- -------</span><br><span class="line">| long1 | long1 | long1 | long1 |</span><br><span class="line">------- ------- ------- -------</span><br><span class="line">|       |       |       | long2 |</span><br><span class="line">------- ------- ------- --------</span><br><span class="line">| long2 | long2 | long2 |       |</span><br><span class="line">------- ------- ------- --------</span><br><span class="line">| ....</span><br></pre></td></tr></table></figure>
<h3 id="6-函数、过程"><a href="#6-函数、过程" class="headerlink" title="6 函数、过程"></a>6 函数、过程</h3><h4 id="6-1：对所调用函数的错误返回码要仔细、全面地处理。"><a href="#6-1：对所调用函数的错误返回码要仔细、全面地处理。" class="headerlink" title="6-1：对所调用函数的错误返回码要仔细、全面地处理。"></a>6-1：对所调用函数的错误返回码要仔细、全面地处理。</h4><h4 id="6-2：明确函数功能，精确（而不是近似）地实现函数设计。"><a href="#6-2：明确函数功能，精确（而不是近似）地实现函数设计。" class="headerlink" title="6-2：明确函数功能，精确（而不是近似）地实现函数设计。"></a>6-2：明确函数功能，精确（而不是近似）地实现函数设计。</h4><h4 id="6-3：编写可重入函数时，应注意局部变量的使用（如编写C-C-语言的可重入函数时，应使用auto即缺省态局部变量或寄存器变量）。"><a href="#6-3：编写可重入函数时，应注意局部变量的使用（如编写C-C-语言的可重入函数时，应使用auto即缺省态局部变量或寄存器变量）。" class="headerlink" title="6-3：编写可重入函数时，应注意局部变量的使用（如编写C/C++语言的可重入函数时，应使用auto即缺省态局部变量或寄存器变量）。"></a>6-3：编写可重入函数时，应注意局部变量的使用（如编写C/C++语言的可重入函数时，应使用auto即缺省态局部变量或寄存器变量）。</h4><p>说明：编写C/C++语言的可重入函数时，不应使用static局部变量，否则必须经过特殊处理，才能使函数具有可重入性。</p>
<h4 id="6-4：编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。"><a href="#6-4：编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。" class="headerlink" title="6-4：编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。"></a>6-4：编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。</h4><p>说明：若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。</p>
<p>示例：假设Exam是int型全局变量，函数Squre_Exam返回Exam平方值。那么如下函数不具有可重入性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">example</span><span class="params">( <span class="keyword">int</span> para )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    Exam = para; <span class="comment">// （**）</span></span><br><span class="line"></span><br><span class="line">    temp = Square_Exam( );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数若被多个进程调用的话，其结果可能是未知的，因为当（**）语句刚执行完后，另外一个使用本函数的进程可能正好被激活，那么当新激活的进程执行到此函数时，将使Exam赋与另一个不同的para值，所以当控制重新回到“temp = Square_Exam( )”后，计算出的temp很可能不是预想中的结果。此函数应如下改进。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">example</span><span class="params">( <span class="keyword">int</span> para )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    [申请信号量操作]          <span class="comment">// 若申请不到“信号量”，说明另外的进程正处于</span></span><br><span class="line"></span><br><span class="line">    Exam = para;            <span class="comment">// 给Exam赋值并计算其平方过程中（即正在使用此</span></span><br><span class="line"></span><br><span class="line">    temp = Square_Exam( );  <span class="comment">// 信号），本进程必须等待其释放信号后，才可继</span></span><br><span class="line"></span><br><span class="line">    [释放信号量操作]          <span class="comment">// 续执行。若申请到信号，则可继续执行，但其</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 它进程必须等待本进程释放信号量后，才能再使</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 用本信号。</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-5：在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。"><a href="#6-5：在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。" class="headerlink" title="6-5：在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。"></a>6-5：在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。</h4><p>说明：对于模块间接口函数的参数的合法性检查这一问题，往往有两个极端现象，即：要么是调用者和被调用者对参数均不作合法性检查，结果就遗漏了合法性检查这一必要的处理过程，造成问题隐患；要么就是调用者和被调用者均对参数进行合法性检查，这种情况虽不会造成问题，但产生了冗余代码，降低了效率。</p>
<h4 id="½6-1：防止将函数的参数作为工作变量。"><a href="#½6-1：防止将函数的参数作为工作变量。" class="headerlink" title="½6-1：防止将函数的参数作为工作变量。"></a>½6-1：防止将函数的参数作为工作变量。</h4><p>说明：将函数的参数作为工作变量，有可能错误地改变参数内容，所以很危险。对必须改变的参数，最好先用局部变量代之，最后再将该局部变量的内容赋给该参数。</p>
<p>示例：下函数的实现不太好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_data</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> num, <span class="keyword">int</span> *data, <span class="keyword">int</span> *sum )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    *sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; num; count++)</span><br><span class="line">    &#123;</span><br><span class="line">        *sum  += data[count]; <span class="comment">// sum成了工作变量，不太好。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若改为如下，则更好些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_data</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> num, <span class="keyword">int</span> *data, <span class="keyword">int</span> *sum )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count ;</span><br><span class="line">    <span class="keyword">int</span> sum_temp;</span><br><span class="line"></span><br><span class="line">    sum_temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; num; count ++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum_temp  += data[count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *sum = sum_temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="½6-2：函数的规模尽量限制在200行以内。"><a href="#½6-2：函数的规模尽量限制在200行以内。" class="headerlink" title="½6-2：函数的规模尽量限制在200行以内。"></a>½6-2：函数的规模尽量限制在200行以内。</h4><p>说明：不包括注释和空格行<em>。</em></p>
<h4 id="½6-3：一个函数仅完成一件功能。"><a href="#½6-3：一个函数仅完成一件功能。" class="headerlink" title="½6-3：一个函数仅完成一件功能。"></a>½6-3：一个函数仅完成一件功能。</h4><h4 id="½6-4：为简单功能编写函数。"><a href="#½6-4：为简单功能编写函数。" class="headerlink" title="½6-4：为简单功能编写函数。"></a>½6-4：为简单功能编写函数。</h4><p>说明：虽然为仅用一两行就可完成的功能去编函数好象没有必要，但用函数可使功能明确化，增加程序可读性，亦可方便维护、测试。</p>
<p>示例：如下语句的功能不很明显。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = ( a &gt; b ) ? a : b ;</span><br></pre></td></tr></table></figure>
<p>改为如下就很清晰了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a &gt; b) ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">value = max (a, b);</span><br></pre></td></tr></table></figure>
<p>或改为如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX (a, b) (((a) &gt; (b)) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line">value = MAX (a, b);</span><br></pre></td></tr></table></figure>
<h4 id="½6-5：不要设计多用途面面俱到的函数。"><a href="#½6-5：不要设计多用途面面俱到的函数。" class="headerlink" title="½6-5：不要设计多用途面面俱到的函数。"></a>½6-5：不要设计多用途面面俱到的函数。</h4><p>说明：多功能集于一身的函数，很可能使函数的理解、测试、维护等变得困难。</p>
<h4 id="½6-6：函数的功能应该是可以预测的，也就是只要输入数据相同就应产生同样的输出。"><a href="#½6-6：函数的功能应该是可以预测的，也就是只要输入数据相同就应产生同样的输出。" class="headerlink" title="½6-6：函数的功能应该是可以预测的，也就是只要输入数据相同就应产生同样的输出。"></a>½6-6：函数的功能应该是可以预测的，也就是只要输入数据相同就应产生同样的输出。</h4><p>说明：带有内部“存储器”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器（如某标记）的状态。这样的函数既不易于理解又不利于测试和维护。在C/C++语言中，函数的static局部变量是函数的内部存储器，有可能使函数的功能不可预测，然而，当某函数的返回值为指针类型时，则必须是STATIC的局部变量的地址作为返回值，若为AUTO类，则返回为错针。</p>
<p>示例：如下函数，其返回值（即功能）是不可预测的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">integer_sum</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> base )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 注意，是static类型的。</span></span><br><span class="line">                                 <span class="comment">// 若改为auto类型，则函数即变为可预测。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">1</span>; index &lt;= base; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="½6-7：尽量不要编写依赖于其他函数内部实现的函数。"><a href="#½6-7：尽量不要编写依赖于其他函数内部实现的函数。" class="headerlink" title="½6-7：尽量不要编写依赖于其他函数内部实现的函数。"></a>½6-7：尽量不要编写依赖于其他函数内部实现的函数。</h4><p>说明：此条为函数独立性的基本要求。由于目前大部分高级语言都是结构化的，所以通过具体语言的语法要求与编译器功能，基本就可以防止这种情况发生。但在汇编语言中，由于其灵活性，很可能使函数出现这种情况。</p>
<p>示例：如下是在DOS下TASM的汇编程序例子。过程Print_Msg的实现依赖于Input_Msg的具体实现，这种程序是非结构化的，难以维护、修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...  <span class="comment">// 程序代码</span></span><br><span class="line"></span><br><span class="line">proc Print_Msg <span class="comment">// 过程（函数）Print_Msg</span></span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// 程序代码</span></span><br><span class="line"></span><br><span class="line">    jmp  LABEL</span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// 程序代码</span></span><br><span class="line"></span><br><span class="line">endp</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">proc Input_Msg <span class="comment">// 过程（函数）Input_Msg</span></span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// 程序代码</span></span><br><span class="line"></span><br><span class="line">LABEL:</span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// 程序代码</span></span><br><span class="line"></span><br><span class="line">endp</span><br></pre></td></tr></table></figure>
<h4 id="½6-8：避免设计多参数函数，不使用的参数从接口中去掉。"><a href="#½6-8：避免设计多参数函数，不使用的参数从接口中去掉。" class="headerlink" title="½6-8：避免设计多参数函数，不使用的参数从接口中去掉。"></a>½6-8：避免设计多参数函数，不使用的参数从接口中去掉。</h4><p>说明：目的减少函数间接口的复杂度。</p>
<h4 id="½6-9：非调度函数应减少或防止控制参数，尽量只使用数据参数。"><a href="#½6-9：非调度函数应减少或防止控制参数，尽量只使用数据参数。" class="headerlink" title="½6-9：非调度函数应减少或防止控制参数，尽量只使用数据参数。"></a>½6-9：非调度函数应减少或防止控制参数，尽量只使用数据参数。</h4><p>说明：本建议目的是防止函数间的控制耦合。调度函数是指根据输入的消息类型或控制命令，来启动相应的功能实体（即函数或过程），而本身并不完成具体功能。控制参数是指改变函数功能行为的参数，即函数要根据此参数来决定具体怎样工作。非调度函数的控制参数增加了函数间的控制耦合，很可能使函数间的耦合度增大，并使函数的功能不唯一。</p>
<p>示例：如下函数构造不太合理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_sub</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">char</span> add_sub_flg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (add_sub_flg == INTEGER_ADD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (a  b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不如分为如下两个函数清晰。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a  b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="½6-10：检查函数所有参数输入的有效性。"><a href="#½6-10：检查函数所有参数输入的有效性。" class="headerlink" title="½6-10：检查函数所有参数输入的有效性。"></a>½6-10：检查函数所有参数输入的有效性。</h4><h4 id="½6-11：检查函数所有非参数输入的有效性，如数据文件、公共变量等。"><a href="#½6-11：检查函数所有非参数输入的有效性，如数据文件、公共变量等。" class="headerlink" title="½6-11：检查函数所有非参数输入的有效性，如数据文件、公共变量等。"></a>½6-11：检查函数所有非参数输入的有效性，如数据文件、公共变量等。</h4><p>说明：函数的输入主要有两种：一种是参数输入；另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入之前，应进行必要的检查。</p>
<h4 id="½6-12：函数名应准确描述函数的功能。"><a href="#½6-12：函数名应准确描述函数的功能。" class="headerlink" title="½6-12：函数名应准确描述函数的功能。"></a>½6-12：函数名应准确描述函数的功能。</h4><h4 id="½6-13：使用动宾词组为执行某操作的函数命名。如果是OOP方法，可以只有动词（名词是对象本身）。"><a href="#½6-13：使用动宾词组为执行某操作的函数命名。如果是OOP方法，可以只有动词（名词是对象本身）。" class="headerlink" title="½6-13：使用动宾词组为执行某操作的函数命名。如果是OOP方法，可以只有动词（名词是对象本身）。"></a>½6-13：使用动宾词组为执行某操作的函数命名。如果是OOP方法，可以只有动词（名词是对象本身）。</h4><p>示例：参照如下方式命名函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_record</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">int</span> rec_ind )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">input_record</span><span class="params">( <span class="keyword">void</span> )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">get_current_color</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br></pre></td></tr></table></figure>
<h4 id="½6-14：避免使用无意义或含义不清的动词为函数命名。"><a href="#½6-14：避免使用无意义或含义不清的动词为函数命名。" class="headerlink" title="½6-14：避免使用无意义或含义不清的动词为函数命名。"></a>½6-14：避免使用无意义或含义不清的动词为函数命名。</h4><p>说明：避免用含义不清的动词如process、handle等为函数命名，因为这些动词并没有说明要具体做什么。</p>
<h4 id="½6-15：函数的返回值要清楚、明了，让使用者不容易忽视错误情况。"><a href="#½6-15：函数的返回值要清楚、明了，让使用者不容易忽视错误情况。" class="headerlink" title="½6-15：函数的返回值要清楚、明了，让使用者不容易忽视错误情况。"></a>½6-15：函数的返回值要清楚、明了，让使用者不容易忽视错误情况。</h4><p>说明：函数的每种出错返回值的意义要清晰、明了、准确，防止使用者误用、理解错误或忽视错误返回码。</p>
<h4 id="½6-16：除非必要，最好不要把与函数返回值类型不同的变量，以编译系统默认的转换方式或强制的转换方式作为返回值返回。"><a href="#½6-16：除非必要，最好不要把与函数返回值类型不同的变量，以编译系统默认的转换方式或强制的转换方式作为返回值返回。" class="headerlink" title="½6-16：除非必要，最好不要把与函数返回值类型不同的变量，以编译系统默认的转换方式或强制的转换方式作为返回值返回。"></a>½6-16：除非必要，最好不要把与函数返回值类型不同的变量，以编译系统默认的转换方式或强制的转换方式作为返回值返回。</h4><h4 id="½6-17：让函数在调用点显得易懂、容易理解。"><a href="#½6-17：让函数在调用点显得易懂、容易理解。" class="headerlink" title="½6-17：让函数在调用点显得易懂、容易理解。"></a>½6-17：让函数在调用点显得易懂、容易理解。</h4><h4 id="½6-18：在调用函数填写参数时，应尽量减少没有必要的默认数据类型转换或强制数据类型转换。"><a href="#½6-18：在调用函数填写参数时，应尽量减少没有必要的默认数据类型转换或强制数据类型转换。" class="headerlink" title="½6-18：在调用函数填写参数时，应尽量减少没有必要的默认数据类型转换或强制数据类型转换。"></a>½6-18：在调用函数填写参数时，应尽量减少没有必要的默认数据类型转换或强制数据类型转换。</h4><p>说明：因为数据类型转换或多或少存在危险。</p>
<h4 id="½6-19：避免函数中不必要语句，防止程序中的垃圾代码。"><a href="#½6-19：避免函数中不必要语句，防止程序中的垃圾代码。" class="headerlink" title="½6-19：避免函数中不必要语句，防止程序中的垃圾代码。"></a>½6-19：避免函数中不必要语句，防止程序中的垃圾代码。</h4><p>说明：程序中的垃圾代码不仅占用额外的空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦。</p>
<h4 id="½6-20：防止把没有关联的语句放到一个函数中。"><a href="#½6-20：防止把没有关联的语句放到一个函数中。" class="headerlink" title="½6-20：防止把没有关联的语句放到一个函数中。"></a>½6-20：防止把没有关联的语句放到一个函数中。</h4><p>说明：防止函数或过程内出现随机内聚。随机内聚是指将没有关联或关联很弱的语句放到同一个函数或过程中。随机内聚给函数或过程的维护、测试及以后的升级等造成了不便，同时也使函数或过程的功能不明确。使用随机内聚函数，常常容易出现在一种应用场合需要改进此函数，而另一种应用场合又不允许这种改进，从而陷入困境。</p>
<p>在编程时，经常遇到在不同函数中使用相同的代码，许多开发人员都愿把这些代码提出来，并构成一个新函数。若这些代码关联较大并且是完成一个功能的，那么这种构造是合理的，否则这种构造将产生随机内聚的函数。</p>
<p>示例：如下函数就是一种随机内聚。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Var</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect.length = <span class="number">0</span>;</span><br><span class="line">    Rect.width = <span class="number">0</span>; <span class="comment">/* 初始化矩形的长与宽 */</span></span><br><span class="line"></span><br><span class="line">    Point.x = <span class="number">10</span>;</span><br><span class="line">    Point.y = <span class="number">10</span>;   <span class="comment">/* 初始化“点”的坐标 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩形的长、宽与点的坐标基本没有任何关系，故以上函数是随机内聚。</p>
<p>应如下分为两个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Rect</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rect.length = <span class="number">0</span>;</span><br><span class="line">    Rect.width = <span class="number">0</span>; <span class="comment">/* 初始化矩形的长与宽 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_Point</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point.x = <span class="number">10</span>;</span><br><span class="line">    Point.y = <span class="number">10</span>;   <span class="comment">/* 初始化“点”的坐标 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="½6-21：如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题。"><a href="#½6-21：如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题。" class="headerlink" title="½6-21：如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题。"></a>½6-21：如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题。</h4><p>说明：若此段代码各语句之间有实质性关联并且是完成同一件功能的，那么可考虑把此段代码构造成一个新的函数。</p>
<h4 id="½6-22：功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。"><a href="#½6-22：功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。" class="headerlink" title="½6-22：功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。"></a>½6-22：功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。</h4><p>说明：模块中函数划分的过多，一般会使函数间的接口变得复杂。所以过小的函数，特别是扇入很低的或功能不明确的函数，不值得单独存在。</p>
<h4 id="½6-23：设计高扇入、合理扇出（小于7）的函数。"><a href="#½6-23：设计高扇入、合理扇出（小于7）的函数。" class="headerlink" title="½6-23：设计高扇入、合理扇出（小于7）的函数。"></a>½6-23：设计高扇入、合理扇出（小于7）的函数。</h4><p>说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。</p>
<p>扇出过大，表明函数过分复杂，需要控制和协调过多的下级函数；而扇出过小，如总是1，表明函数的调用层次可能过多，这样不利程序阅读和函数结构的分析，并且程序运行时会对系统资源如堆栈空间等造成压力。函数较合理的扇出（调度函数除外）通常是3-5。扇出太大，一般是由于缺乏中间层次，可适当增加中间层次的函数。扇出太小，可把下级函数进一步分解多个函数，或合并到上级函数中。当然分解或合并函数时，不能改变要实现的功能，也不能违背函数间的独立性。</p>
<p>扇入越大，表明使用此函数的上级函数越多，这样的函数使用效率高，但不能违背函数间的独立性而单纯地追求高扇入。公共模块中的函数及底层函数应该有较高的扇入。</p>
<p>较良好的软件结构通常是顶层函数的扇出较高，中层函数的扇出较少，而底层函数则扇入到公共模块中。</p>
<h4 id="½6-24：减少函数本身或函数间的递归调用。"><a href="#½6-24：减少函数本身或函数间的递归调用。" class="headerlink" title="½6-24：减少函数本身或函数间的递归调用。"></a>½6-24：减少函数本身或函数间的递归调用。</h4><p>说明：递归调用特别是函数间的递归调用（如A-&gt;B-&gt;C-&gt;A），影响程序的可理解性；递归调用一般都占用较多的系统资源（如栈空间）；递归调用对程序的测试有一定影响。故除非为某些算法或功能的实现方便，应减少没必要的递归调用。</p>
<h4 id="½6-25：仔细分析模块的功能及性能需求，并进一步细分，同时若有必要画出有关数据流图，据此来进行模块的函数划分与组织。"><a href="#½6-25：仔细分析模块的功能及性能需求，并进一步细分，同时若有必要画出有关数据流图，据此来进行模块的函数划分与组织。" class="headerlink" title="½6-25：仔细分析模块的功能及性能需求，并进一步细分，同时若有必要画出有关数据流图，据此来进行模块的函数划分与组织。"></a>½6-25：仔细分析模块的功能及性能需求，并进一步细分，同时若有必要画出有关数据流图，据此来进行模块的函数划分与组织。</h4><p>说明：函数的划分与组织是模块的实现过程中很关键的步骤，如何划分出合理的函数结构，关系到模块的最终效率和可维护性、可测性等。根据模块的功能图或/及数据流图映射出函数结构是常用方法之一。</p>
<h4 id="½6-26：改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性以及代码可读性、效率和可维护性。优化函数结构时，要遵守以下原则："><a href="#½6-26：改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性以及代码可读性、效率和可维护性。优化函数结构时，要遵守以下原则：" class="headerlink" title="½6-26：改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性以及代码可读性、效率和可维护性。优化函数结构时，要遵守以下原则："></a>½6-26：改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性以及代码可读性、效率和可维护性。优化函数结构时，要遵守以下原则：</h4><p>（1）不能影响模块功能的实现。</p>
<p>（2）仔细考查模块或函数出错处理及模块的性能要求并进行完善。</p>
<p>（3）通过分解或合并函数来改进软件结构。</p>
<p>（4）考查函数的规模，过大的要进行分解。</p>
<p>（5）降低函数间接口的复杂度。</p>
<p>（6）不同层次的函数调用要有较合理的扇入、扇出。</p>
<p>（7）函数功能应可预测。</p>
<p>（8）提高函数内聚。（单一功能的函数内聚最高）</p>
<p>说明：对初步划分后的函数结构应进行改进、优化，使之更为合理。</p>
<h4 id="½6-27：在多任务操作系统的环境下编程，要注意函数可重入性的构造。"><a href="#½6-27：在多任务操作系统的环境下编程，要注意函数可重入性的构造。" class="headerlink" title="½6-27：在多任务操作系统的环境下编程，要注意函数可重入性的构造。"></a>½6-27：在多任务操作系统的环境下编程，要注意函数可重入性的构造。</h4><p>说明：可重入性是指函数可以被多个任务进程调用。在多任务操作系统中，函数是否具有可重入性是非常重要的，因为这是多个进程可以共用此函数的必要条件。另外，编译器是否提供可重入函数库，与它所服务的操作系统有关，只有操作系统是多任务时，编译器才有可能提供可重入函数库。如DOS下BC和MSC等就不具备可重入函数库，因为DOS是单用户单任务操作系统。</p>
<h4 id="½6-28：避免使用BOOL参数。"><a href="#½6-28：避免使用BOOL参数。" class="headerlink" title="½6-28：避免使用BOOL参数。"></a>½6-28：避免使用BOOL参数。</h4><p>说明：原因有二，其一是BOOL参数值无意义，TURE/FALSE的含义是非常模糊的，在调用时很难知道该参数到底传达的是什么意思；其二是BOOL参数值不利于扩充。还有NULL也是一个无意义的单词。</p>
<h4 id="½6-29：-对于提供了返回值的函数，在引用时最好使用其返回值。"><a href="#½6-29：-对于提供了返回值的函数，在引用时最好使用其返回值。" class="headerlink" title="½6-29： 对于提供了返回值的函数，在引用时最好使用其返回值。"></a>½6-29： 对于提供了返回值的函数，在引用时最好使用其返回值。</h4><h4 id="½6-30：当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。"><a href="#½6-30：当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。" class="headerlink" title="½6-30：当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。"></a>½6-30：当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。</h4><p>说明：这样可以增加编程效率和程序的可读性。</p>
<p>示例：在某过程中较多引用TheReceiveBuffer[FirstSocket].byDataPtr，</p>
<p>则可以通过以下宏定义来代替：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> pSOCKDATA TheReceiveBuffer[FirstScoket].byDataPtr</span></span><br></pre></td></tr></table></figure>
<h3 id="7-可测性"><a href="#7-可测性" class="headerlink" title="7 可测性"></a>7 可测性</h3><h4 id="7-1：在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。"><a href="#7-1：在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。" class="headerlink" title="7-1：在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。"></a>7-1：在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。</h4><p>说明：本规则是针对项目组或产品组的。</p>
<h4 id="7-2：在同一项目组或产品组内，调测打印出的信息串的格式要有统一的形式。信息串中至少要有所在模块名（或源文件名）及行号。"><a href="#7-2：在同一项目组或产品组内，调测打印出的信息串的格式要有统一的形式。信息串中至少要有所在模块名（或源文件名）及行号。" class="headerlink" title="7-2：在同一项目组或产品组内，调测打印出的信息串的格式要有统一的形式。信息串中至少要有所在模块名（或源文件名）及行号。"></a>7-2：在同一项目组或产品组内，调测打印出的信息串的格式要有统一的形式。信息串中至少要有所在模块名（或源文件名）及行号。</h4><p>说明：统一的调测信息格式便于集成测试。</p>
<h4 id="7-3：编程的同时要为单元测试选择恰当的测试点，并仔细构造测试代码、测试用例，同时给出明确的注释说明。测试代码部分应作为（模块中的）一个子模块，以方便测试代码在模块中的安装与拆卸（通过调测开关）。"><a href="#7-3：编程的同时要为单元测试选择恰当的测试点，并仔细构造测试代码、测试用例，同时给出明确的注释说明。测试代码部分应作为（模块中的）一个子模块，以方便测试代码在模块中的安装与拆卸（通过调测开关）。" class="headerlink" title="7-3：编程的同时要为单元测试选择恰当的测试点，并仔细构造测试代码、测试用例，同时给出明确的注释说明。测试代码部分应作为（模块中的）一个子模块，以方便测试代码在模块中的安装与拆卸（通过调测开关）。"></a>7-3：编程的同时要为单元测试选择恰当的测试点，并仔细构造测试代码、测试用例，同时给出明确的注释说明。测试代码部分应作为（模块中的）一个子模块，以方便测试代码在模块中的安装与拆卸（通过调测开关）。</h4><p>说明：为单元测试而准备。</p>
<h4 id="7-4：在进行集成测试-系统联调之前，要构造好测试环境、测试项目及测试用例，同时仔细分析并优化测试用例，以提高测试效率。"><a href="#7-4：在进行集成测试-系统联调之前，要构造好测试环境、测试项目及测试用例，同时仔细分析并优化测试用例，以提高测试效率。" class="headerlink" title="7-4：在进行集成测试/系统联调之前，要构造好测试环境、测试项目及测试用例，同时仔细分析并优化测试用例，以提高测试效率。"></a>7-4：在进行集成测试/系统联调之前，要构造好测试环境、测试项目及测试用例，同时仔细分析并优化测试用例，以提高测试效率。</h4><p>说明：好的测试用例应尽可能模拟出程序所遇到的边界值、各种复杂环境及一些极端情况等。</p>
<h4 id="7-5：使用断言来发现软件问题，提高代码可测性。"><a href="#7-5：使用断言来发现软件问题，提高代码可测性。" class="headerlink" title="7-5：使用断言来发现软件问题，提高代码可测性。"></a>7-5：使用断言来发现软件问题，提高代码可测性。</h4><p>说明：断言是对某种假设条件进行检查（可理解为若条件成立则无动作，否则应报告），它可以快速发现并定位软件问题，同时对系统错误进行自动报警。断言可以对在系统中隐藏很深，用其它手段极难发现的问题进行定位，从而缩短软件问题定位时间，提高系统的可测性。实际应用时，可根据具体情况灵活地设计断言。</p>
<p>示例：下面是C语言中的一个断言，用宏来设计的。（其中NULL为0L）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _EXAM_ASSERT_TEST_  <span class="comment">// 若使用断言测试</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exam_assert</span><span class="params">( <span class="keyword">char</span> * file_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> line_no )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"\n[EXAM]Assert failed: %s, line %u\n"</span>,</span><br><span class="line">            file_name, line_no );</span><br><span class="line">    <span class="built_in">abort</span>( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  EXAM_ASSERT( condition )</span></span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="comment">// 若条件成立，则无动作</span></span><br><span class="line">        <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 否则报告</span></span><br><span class="line">        exam_assert( __FILE__, __LINE__ )</span><br><span class="line"></span><br><span class="line">#<span class="keyword">else</span>  <span class="comment">// 若不使用断言测试</span></span><br><span class="line"></span><br><span class="line">#define EXAM_ASSERT(condition)  <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">#endif  <span class="comment">/* end of ASSERT */</span></span><br></pre></td></tr></table></figure>
<h4 id="7-6：用断言来检查程序正常运行时不应发生但在调测时有可能发生的非法情况。"><a href="#7-6：用断言来检查程序正常运行时不应发生但在调测时有可能发生的非法情况。" class="headerlink" title="7-6：用断言来检查程序正常运行时不应发生但在调测时有可能发生的非法情况。"></a>7-6：用断言来检查程序正常运行时不应发生但在调测时有可能发生的非法情况。</h4><h4 id="7-7：不能用断言来检查最终产品肯定会出现且必须处理的错误情况。"><a href="#7-7：不能用断言来检查最终产品肯定会出现且必须处理的错误情况。" class="headerlink" title="7-7：不能用断言来检查最终产品肯定会出现且必须处理的错误情况。"></a>7-7：不能用断言来检查最终产品肯定会出现且必须处理的错误情况。</h4><p>说明：断言是用来处理不应该发生的错误情况的，对于可能会发生的且必须处理的情况要写防错程序，而不是断言。如某模块收到其它模块或链路上的消息后，要对消息的合理性进行检查，此过程为正常的错误检查，不能用断言来实现。</p>
<h4 id="7-8：对较复杂的断言加上明确的注释。"><a href="#7-8：对较复杂的断言加上明确的注释。" class="headerlink" title="7-8：对较复杂的断言加上明确的注释。"></a>7-8：对较复杂的断言加上明确的注释。</h4><p>说明：为复杂的断言加注释，可澄清断言含义并减少不必要的误用。</p>
<h4 id="7-9：用断言确认函数的参数。"><a href="#7-9：用断言确认函数的参数。" class="headerlink" title="7-9：用断言确认函数的参数。"></a>7-9：用断言确认函数的参数。</h4><p>示例：假设某函数参数中有一个指针，那么使用指针前可对它检查，如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exam_fun</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">char</span> *str )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EXAM_ASSERT( str != <span class="literal">NULL</span> );  <span class="comment">// 用断言检查“假设指针不为空”这个条件</span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//other program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-10：用断言保证没有定义的特性或功能不被使用。"><a href="#7-10：用断言保证没有定义的特性或功能不被使用。" class="headerlink" title="7-10：用断言保证没有定义的特性或功能不被使用。"></a>7-10：用断言保证没有定义的特性或功能不被使用。</h4><p>示例：假设某通信模块在设计时，准备提供“无连接”和“连接” 这两种业务。但当前的版本中仅实现了“无连接”业务，且在此版本的正式发行版中，用户（上层模块）不应产生“连接”业务的请求，那么在测试时可用断言检查用户是否使用“连接”业务。如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXAM_CONNECTIONLESS 0 <span class="comment">// 无连接业务</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXAM_CONNECTION     1 <span class="comment">// 连接业务</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msg_process</span><span class="params">( EXAM_MESSAGE *msg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> service; <span class="comment">/* message service class */</span></span><br><span class="line"></span><br><span class="line">    EXAM_ASSERT( msg != <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">	service = get_msg_service_class( msg );</span><br><span class="line"></span><br><span class="line">    EXAM_ASSERT( service != EXAM_CONNECTION ); <span class="comment">// 假设不使用连接业务</span></span><br><span class="line"> </span><br><span class="line">    ...  <span class="comment">//other program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-11：用断言对程序开发环境（OS-Compiler-Hardware）的假设进行检查。"><a href="#7-11：用断言对程序开发环境（OS-Compiler-Hardware）的假设进行检查。" class="headerlink" title="7-11：用断言对程序开发环境（OS/Compiler/Hardware）的假设进行检查。"></a>7-11：用断言对程序开发环境（OS/Compiler/Hardware）的假设进行检查。</h4><p>说明：程序运行时所需的软硬件环境及配置要求，不能用断言来检查，而必须由一段专门代码处理。用断言仅可对程序开发环境中的假设及所配置的某版本软硬件是否具有某种功能的假设进行检查。如某网卡是否在系统运行环境中配置了，应由程序中正式代码来检查；而此网卡是否具有某设想的功能，则可由断言来检查。</p>
<p>对编译器提供的功能及特性假设可用断言检查，原因是软件最终产品（即运行代码或机器码）与编译器已没有任何直接关系，即软件运行过程中（注意不是编译过程中）不会也不应该对编译器的功能提出任何需求。</p>
<p>示例：用断言检查编译器的int型数据占用的内存空间是否为2，如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXAM_ASSERT( <span class="keyword">sizeof</span>( <span class="keyword">int</span> ) == <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
<h4 id="7-12：正式软件产品中应把断言及其它调测代码去掉（即把有关的调测开关关掉）。"><a href="#7-12：正式软件产品中应把断言及其它调测代码去掉（即把有关的调测开关关掉）。" class="headerlink" title="7-12：正式软件产品中应把断言及其它调测代码去掉（即把有关的调测开关关掉）。"></a>7-12：正式软件产品中应把断言及其它调测代码去掉（即把有关的调测开关关掉）。</h4><p>说明：加快软件运行速度。</p>
<h4 id="7-13：在软件系统中设置与取消有关测试手段，不能对软件实现的功能等产生影响。"><a href="#7-13：在软件系统中设置与取消有关测试手段，不能对软件实现的功能等产生影响。" class="headerlink" title="7-13：在软件系统中设置与取消有关测试手段，不能对软件实现的功能等产生影响。"></a>7-13：在软件系统中设置与取消有关测试手段，不能对软件实现的功能等产生影响。</h4><p>说明：即有测试代码的软件和关掉测试代码的软件，在功能行为上应一致。</p>
<h4 id="7-14：用调测开关来切换软件的DEBUG版和正式版，而不要同时存在正式版本和DEBUG版本的不同源文件，以减少维护的难度。"><a href="#7-14：用调测开关来切换软件的DEBUG版和正式版，而不要同时存在正式版本和DEBUG版本的不同源文件，以减少维护的难度。" class="headerlink" title="7-14：用调测开关来切换软件的DEBUG版和正式版，而不要同时存在正式版本和DEBUG版本的不同源文件，以减少维护的难度。"></a>7-14：用调测开关来切换软件的DEBUG版和正式版，而不要同时存在正式版本和DEBUG版本的不同源文件，以减少维护的难度。</h4><h4 id="7-15：软件的DEBUG版本和发行版本应该统一维护，不允许分家，并且要时刻注意保证两个版本在实现功能上的一致性。"><a href="#7-15：软件的DEBUG版本和发行版本应该统一维护，不允许分家，并且要时刻注意保证两个版本在实现功能上的一致性。" class="headerlink" title="7-15：软件的DEBUG版本和发行版本应该统一维护，不允许分家，并且要时刻注意保证两个版本在实现功能上的一致性。"></a>7-15：软件的DEBUG版本和发行版本应该统一维护，不允许分家，并且要时刻注意保证两个版本在实现功能上的一致性。</h4><h4 id="½7-1：在编写代码之前，应预先设计好程序调试与测试的方法和手段，并设计好各种调测开关及相应测试代码如打印函数等。"><a href="#½7-1：在编写代码之前，应预先设计好程序调试与测试的方法和手段，并设计好各种调测开关及相应测试代码如打印函数等。" class="headerlink" title="½7-1：在编写代码之前，应预先设计好程序调试与测试的方法和手段，并设计好各种调测开关及相应测试代码如打印函数等。"></a>½7-1：在编写代码之前，应预先设计好程序调试与测试的方法和手段，并设计好各种调测开关及相应测试代码如打印函数等。</h4><p>说明：程序的调试与测试是软件生存周期中很重要的一个阶段，如何对软件进行较全面、高率的测试并尽可能地找出软件中的错误就成为很关键的问题。因此在编写源代码之前，除了要有一套比较完善的测试计划外，还应设计出一系列代码测试手段，为单元测试、集成测试及系统联调提供方便。</p>
<h4 id="½7-2：调测开关应分为不同级别和类型。"><a href="#½7-2：调测开关应分为不同级别和类型。" class="headerlink" title="½7-2：调测开关应分为不同级别和类型。"></a>½7-2：调测开关应分为不同级别和类型。</h4><p>说明：调测开关的设置及分类应从以下几方面考虑：针对模块或系统某部分代码的调测；针对模块或系统某功能的调测；出于某种其它目的，如对性能、容量等的测试。这样做便于软件功能的调测，并且便于模块的单元测试、系统联调等。</p>
<h4 id="½7-3：编写防错程序，然后在处理错误之后可用断言宣布发生错误。"><a href="#½7-3：编写防错程序，然后在处理错误之后可用断言宣布发生错误。" class="headerlink" title="½7-3：编写防错程序，然后在处理错误之后可用断言宣布发生错误。"></a>½7-3：编写防错程序，然后在处理错误之后可用断言宣布发生错误。</h4><p>示例：假如某模块收到通信链路上的消息，则应对消息的合法性进行检查，若消息类别不是通信协议中规定的，则应进行出错处理，之后可用断言报告，如下例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _EXAM_ASSERT_TEST_ <span class="comment">// 若使用断言测试</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Notice: this function does not call 'abort' to exit program */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert_report</span><span class="params">( <span class="keyword">char</span> * file_name, <span class="keyword">unsigned</span> <span class="keyword">int</span> line_no )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"\n[EXAM]Error Report: %s, line %u\n"</span>,</span><br><span class="line">            file_name, line_no );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ASSERT_REPORT( condition )</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( condition ) <span class="comment">// 若条件成立，则无动作</span></span><br><span class="line"></span><br><span class="line">        <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 否则报告</span></span><br><span class="line"></span><br><span class="line">        assert_report ( __FILE__, __LINE__ )</span><br><span class="line"></span><br><span class="line">#<span class="keyword">else</span> <span class="comment">// 若不使用断言测试</span></span><br><span class="line"></span><br><span class="line">#define ASSERT_REPORT( condition )  <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">#endif <span class="comment">/* end of ASSERT */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> msg_handle( <span class="keyword">unsigned</span> <span class="keyword">char</span> msg_name, <span class="keyword">unsigned</span> <span class="keyword">char</span> * msg )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>( msg_name )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_ONE:</span><br><span class="line">            ... <span class="comment">// 消息MSG_ONE处理</span></span><br><span class="line">            <span class="keyword">return</span> MSG_HANDLE_SUCCESS;  </span><br><span class="line"></span><br><span class="line">            ... <span class="comment">// 其它合法消息处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ... <span class="comment">// 消息出错处理</span></span><br><span class="line">            ASSERT_REPORT( FALSE );  <span class="comment">// “合法”消息不成立，报告</span></span><br><span class="line">            <span class="keyword">return</span> MSG_HANDLE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-程序效率"><a href="#8-程序效率" class="headerlink" title="8 程序效率"></a>8 程序效率</h3><h4 id="8-1：编程时要经常注意代码的效率。"><a href="#8-1：编程时要经常注意代码的效率。" class="headerlink" title="8-1：编程时要经常注意代码的效率。"></a>8-1：编程时要经常注意代码的效率。</h4><p>说明：代码效率分为全局效率、局部效率、时间效率及空间效率。全局效率是站在整个系统的角度上的系统效率；局部效率是站在模块或函数角度上的效率；时间效率是程序处理输入任务所需的时间长短；空间效率是程序所需内存空间，如机器代码空间大小、数据空间大小、栈空间大小等。</p>
<h4 id="8-2：在保证软件系统的正确性、稳定性、可读性及可测性的前提下，提高代码效率。"><a href="#8-2：在保证软件系统的正确性、稳定性、可读性及可测性的前提下，提高代码效率。" class="headerlink" title="8-2：在保证软件系统的正确性、稳定性、可读性及可测性的前提下，提高代码效率。"></a>8-2：在保证软件系统的正确性、稳定性、可读性及可测性的前提下，提高代码效率。</h4><p>说明：不能一味地追求代码效率，而对软件的正确性、稳定性、可读性及可测性造成影响。</p>
<h4 id="8-3：局部效率应为全局效率服务，不能因为提高局部效率而对全局效率造成影响。"><a href="#8-3：局部效率应为全局效率服务，不能因为提高局部效率而对全局效率造成影响。" class="headerlink" title="8-3：局部效率应为全局效率服务，不能因为提高局部效率而对全局效率造成影响。"></a>8-3：局部效率应为全局效率服务，不能因为提高局部效率而对全局效率造成影响。</h4><h4 id="8-4：通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。"><a href="#8-4：通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。" class="headerlink" title="8-4：通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。"></a>8-4：通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。</h4><p>说明：这种方式是解决软件空间效率的根本办法。</p>
<p>示例：如下记录学生学习成绩的结构不合理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>  BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> WORD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT_SCORE_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BYTE name[<span class="number">8</span>];</span><br><span class="line">    BYTE age;</span><br><span class="line">    BYTE sex;</span><br><span class="line">    BYTE <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    BYTE subject;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125; STUDENT_SCORE;</span><br></pre></td></tr></table></figure>
<p>因为每位学生都有多科学习成绩，故如上结构将占用较大空间。应如下改进（分为两个结构），总的存贮空间将变小，操作也变得更方便。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BYTE name[<span class="number">8</span>];</span><br><span class="line">    BYTE age;</span><br><span class="line">    BYTE sex;</span><br><span class="line">    BYTE <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">&#125; STUDENT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STUDENT_SCORE_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WORD student_index;</span><br><span class="line">    BYTE subject;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125; STUDENT_SCORE;</span><br></pre></td></tr></table></figure>
<h4 id="8-5：循环体内工作量最小化。"><a href="#8-5：循环体内工作量最小化。" class="headerlink" title="8-5：循环体内工作量最小化。"></a>8-5：循环体内工作量最小化。</h4><p>说明：应仔细考虑循环体内的语句是否可以放在循环体之外，使循环体内工作量最小，从而提高程序的时间效率。</p>
<p>示例：如下代码效率不高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ind = <span class="number">0</span>; ind &lt; MAX_ADD_NUMBER; ind++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += ind;</span><br><span class="line">    back_sum = sum; <span class="comment">/* backup sum */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句“back_sum = sum;”完全可以放在for语句之后，如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ind = <span class="number">0</span>; ind &lt; MAX_ADD_NUMBER; ind++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += ind;</span><br><span class="line">&#125;</span><br><span class="line">back_sum  = sum; <span class="comment">/* backup sum */</span></span><br></pre></td></tr></table></figure>
<h4 id="½8-1：仔细分析有关算法，并进行优化。"><a href="#½8-1：仔细分析有关算法，并进行优化。" class="headerlink" title="½8-1：仔细分析有关算法，并进行优化。"></a>½8-1：仔细分析有关算法，并进行优化。</h4><h4 id="½8-2：仔细考查、分析系统及模块处理输入（如事务、消息等）的方式，并加以改进。"><a href="#½8-2：仔细考查、分析系统及模块处理输入（如事务、消息等）的方式，并加以改进。" class="headerlink" title="½8-2：仔细考查、分析系统及模块处理输入（如事务、消息等）的方式，并加以改进。"></a>½8-2：仔细考查、分析系统及模块处理输入（如事务、消息等）的方式，并加以改进。</h4><h4 id="½8-3：对模块中函数的划分及组织方式进行分析、优化，改进模块中函数的组织结构，提高程序效率。"><a href="#½8-3：对模块中函数的划分及组织方式进行分析、优化，改进模块中函数的组织结构，提高程序效率。" class="headerlink" title="½8-3：对模块中函数的划分及组织方式进行分析、优化，改进模块中函数的组织结构，提高程序效率。"></a>½8-3：对模块中函数的划分及组织方式进行分析、优化，改进模块中函数的组织结构，提高程序效率。</h4><p>说明：软件系统的效率主要与算法、处理任务方式、系统功能及函数结构有很大关系，仅在代码上下功夫一般不能解决根本问题。</p>
<h4 id="½8-4：编程时，要随时留心代码效率；优化代码时，要考虑周全。"><a href="#½8-4：编程时，要随时留心代码效率；优化代码时，要考虑周全。" class="headerlink" title="½8-4：编程时，要随时留心代码效率；优化代码时，要考虑周全。"></a>½8-4：编程时，要随时留心代码效率；优化代码时，要考虑周全。</h4><h4 id="½8-5：不应花过多的时间拼命地提高调用不很频繁的函数代码效率。"><a href="#½8-5：不应花过多的时间拼命地提高调用不很频繁的函数代码效率。" class="headerlink" title="½8-5：不应花过多的时间拼命地提高调用不很频繁的函数代码效率。"></a>½8-5：不应花过多的时间拼命地提高调用不很频繁的函数代码效率。</h4><p>说明：对代码优化可提高效率，但若考虑不周很有可能引起严重后果。</p>
<h4 id="½8-6：要仔细地构造或直接用汇编编写调用频繁或性能要求极高的函数。"><a href="#½8-6：要仔细地构造或直接用汇编编写调用频繁或性能要求极高的函数。" class="headerlink" title="½8-6：要仔细地构造或直接用汇编编写调用频繁或性能要求极高的函数。"></a>½8-6：要仔细地构造或直接用汇编编写调用频繁或性能要求极高的函数。</h4><p>说明：只有对编译系统产生机器码的方式以及硬件系统较为熟悉时，才可使用汇编嵌入方式。嵌入汇编可提高时间及空间效率，但也存在一定风险。</p>
<h4 id="½8-7：在保证程序质量的前提下，通过压缩代码量、去掉不必要代码以及减少不必要的局部和全局变量，来提高空间效率。"><a href="#½8-7：在保证程序质量的前提下，通过压缩代码量、去掉不必要代码以及减少不必要的局部和全局变量，来提高空间效率。" class="headerlink" title="½8-7：在保证程序质量的前提下，通过压缩代码量、去掉不必要代码以及减少不必要的局部和全局变量，来提高空间效率。"></a>½8-7：在保证程序质量的前提下，通过压缩代码量、去掉不必要代码以及减少不必要的局部和全局变量，来提高空间效率。</h4><p>说明：这种方式对提高空间效率可起到一定作用，但往往不能解决根本问题。</p>
<h4 id="½8-8：在多重循环中，应将最忙的循环放在最内层。"><a href="#½8-8：在多重循环中，应将最忙的循环放在最内层。" class="headerlink" title="½8-8：在多重循环中，应将最忙的循环放在最内层。"></a>½8-8：在多重循环中，应将最忙的循环放在最内层。</h4><p>说明：减少CPU切入循环层的次数。</p>
<p>示例：如下代码效率不高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; <span class="number">100</span>; row++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; <span class="number">5</span>; col++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改为如下方式，以提高效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; <span class="number">5</span>; col++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; <span class="number">100</span>; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="½8-9：尽量减少循环嵌套层次。"><a href="#½8-9：尽量减少循环嵌套层次。" class="headerlink" title="½8-9：尽量减少循环嵌套层次。"></a>½8-9：尽量减少循环嵌套层次。</h4><h4 id="½8-10：避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。"><a href="#½8-10：避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。" class="headerlink" title="½8-10：避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。"></a>½8-10：避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。</h4><p>说明：目的是减少判断次数。循环体中的判断语句是否可以移到循环体外，要视程序的具体情况而言，一般情况，与循环变量无关的判断语句可以移到循环体外，而有关的则不可以。</p>
<p>示例：如下代码效率稍低。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ind = <span class="number">0</span>; ind &lt; MAX_RECT_NUMBER; ind++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_type == RECT_AREA)</span><br><span class="line">    &#123;</span><br><span class="line">        area_sum += rect_area[ind];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rect_length_sum += rect[ind].length;</span><br><span class="line">        rect_width_sum += rect[ind].width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为判断语句与循环变量无关，故可如下改进，以减少判断次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data_type == RECT_AREA)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (ind = <span class="number">0</span>; ind &lt; MAX_RECT_NUMBER; ind++)</span><br><span class="line">    &#123;</span><br><span class="line">        area_sum += rect_area[ind];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (ind = <span class="number">0</span>; ind &lt; MAX_RECT_NUMBER; ind++)</span><br><span class="line">    &#123;</span><br><span class="line">        rect_length_sum += rect[ind].length;</span><br><span class="line">        rect_width_sum  += rect[ind].width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="½8-11：尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。"><a href="#½8-11：尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。" class="headerlink" title="½8-11：尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。"></a>½8-11：尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。</h4><p>说明：浮点运算除法要占用较多CPU资源。</p>
<p>示例：如下表达式运算可能要占较多CPU资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAI 3.1416</span></span><br><span class="line"></span><br><span class="line">radius = circle_length / (<span class="number">2</span> * PAI);</span><br></pre></td></tr></table></figure>
<p>应如下把浮点除法改为浮点乘法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAI_RECIPROCAL (1 / 3.1416 ) <span class="comment">// 编译器编译时，将生成具体浮点数</span></span></span><br><span class="line"></span><br><span class="line">radius = circle_length * PAI_RECIPROCAL / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h4 id="½8-12：不要一味追求紧凑的代码。"><a href="#½8-12：不要一味追求紧凑的代码。" class="headerlink" title="½8-12：不要一味追求紧凑的代码。"></a>½8-12：不要一味追求紧凑的代码。</h4><p>说明：因为紧凑的代码并不代表高效的机器码。</p>
<h3 id="9-质量保证"><a href="#9-质量保证" class="headerlink" title="9 质量保证"></a>9 质量保证</h3><h4 id="9-1：在软件设计过程中构筑软件质量。"><a href="#9-1：在软件设计过程中构筑软件质量。" class="headerlink" title="9-1：在软件设计过程中构筑软件质量。"></a>9-1：在软件设计过程中构筑软件质量。</h4><h4 id="9-2：代码质量保证优先原则"><a href="#9-2：代码质量保证优先原则" class="headerlink" title="9-2：代码质量保证优先原则"></a>9-2：代码质量保证优先原则</h4><p>​     （1）正确性，指程序要实现设计要求的功能。</p>
<p>​     （2）稳定性、安全性，指程序稳定、可靠、安全。</p>
<p>​     （3）可测试性，指程序要具有良好的可测试性。</p>
<p>​     （4）规范/可读性，指程序书写风格、命名规则等要符合规范。</p>
<p>​     （5）全局效率，指软件系统的整体效率。</p>
<p>​     （6）局部效率，指某个模块/子模块/函数的本身效率。</p>
<p>​     （7）个人表达方式/个人方便性，指个人编程习惯。</p>
<h4 id="9-3：只引用属于自己的存贮空间。"><a href="#9-3：只引用属于自己的存贮空间。" class="headerlink" title="9-3：只引用属于自己的存贮空间。"></a>9-3：只引用属于自己的存贮空间。</h4><p>说明：若模块封装的较好，那么一般不会发生非法引用他人的空间。</p>
<h4 id="9-4：防止引用已经释放的内存空间。"><a href="#9-4：防止引用已经释放的内存空间。" class="headerlink" title="9-4：防止引用已经释放的内存空间。"></a>9-4：防止引用已经释放的内存空间。</h4><p>说明：在实际编程过程中，稍不留心就会出现在一个模块中释放了某个内存块（如C语言指针），而另一模块在随后的某个时刻又使用了它。要防止这种情况发生。</p>
<h4 id="9-5：过程-函数中分配的内存，在过程-函数退出之前要释放。"><a href="#9-5：过程-函数中分配的内存，在过程-函数退出之前要释放。" class="headerlink" title="9-5：过程/函数中分配的内存，在过程/函数退出之前要释放。"></a>9-5：过程/函数中分配的内存，在过程/函数退出之前要释放。</h4><h4 id="9-6：过程-函数中申请的（为打开文件而使用的）文件句柄，在过程-函数退出之前要关闭。"><a href="#9-6：过程-函数中申请的（为打开文件而使用的）文件句柄，在过程-函数退出之前要关闭。" class="headerlink" title="9-6：过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。"></a>9-6：过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。</h4><p>说明：分配的内存不释放以及文件句柄不关闭，是较常见的错误，而且稍不注意就有可能发生。这类错误往往会引起很严重后果，且难以定位。</p>
<p>示例：下函数在退出之前，没有把分配的内存释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">example_fun</span><span class="params">( BYTE gt_len, BYTE *gt_code )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BYTE *gt_buf;</span><br><span class="line"></span><br><span class="line">    gt_buf = (BYTE *) <span class="built_in">malloc</span> (MAX_GT_LENGTH);</span><br><span class="line">    ...  <span class="comment">//program code, include check gt_buf if or not NULL.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* global title length error */</span></span><br><span class="line">    <span class="keyword">if</span> (gt_len &gt; MAX_GT_LENGTH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GT_LENGTH_ERROR; <span class="comment">// 忘了释放gt_buf</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// other program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应改为如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">example_fun</span><span class="params">( BYTE gt_len, BYTE *gt_code )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BYTE *gt_buf;</span><br><span class="line"></span><br><span class="line">    gt_buf = (BYTE * ) <span class="built_in">malloc</span> ( MAX_GT_LENGTH );</span><br><span class="line">    ...  <span class="comment">// program code, include check gt_buf if or not NULL.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* global title length error */</span></span><br><span class="line">    <span class="keyword">if</span> (gt_len &gt; MAX_GT_LENGTH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>( gt_buf  ); <span class="comment">// 退出之前释放gt_buf</span></span><br><span class="line">        <span class="keyword">return</span> GT_LENGTH_ERROR; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...  <span class="comment">// other program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-7：防止内存操作越界。"><a href="#9-7：防止内存操作越界。" class="headerlink" title="9-7：防止内存操作越界。"></a>9-7：防止内存操作越界。</h4><p>说明：内存操作主要是指对数组、指针、内存地址等的操作。内存操作越界是软件系统主要错误之一，后果往往非常严重，所以当我们进行这些操作时一定要仔细小心。</p>
<p>示例：假设某软件系统最多可由10个用户同时使用，用户号为1-10，那么如下程序存在问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_USR_NUM 10</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> usr_login_flg[MAX_USR_NUM]= <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_usr_login_flg</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">char</span> usr_no )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!usr_login_flg[usr_no])</span><br><span class="line">    &#123;</span><br><span class="line">        usr_login_flg[usr_no]= TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当usr_no为10时，将使用usr_login_flg越界。可采用如下方式解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_usr_login_flg</span><span class="params">( <span class="keyword">unsigned</span> <span class="keyword">char</span> usr_no )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!usr_login_flg[usr_no - <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        usr_login_flg[usr_no - <span class="number">1</span>]= TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-8：认真处理程序所能遇到的各种出错情况。"><a href="#9-8：认真处理程序所能遇到的各种出错情况。" class="headerlink" title="9-8：认真处理程序所能遇到的各种出错情况。"></a>9-8：认真处理程序所能遇到的各种出错情况。</h4><h4 id="9-9：系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。"><a href="#9-9：系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。" class="headerlink" title="9-9：系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。"></a>9-9：系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。</h4><h4 id="9-10：系统运行之初，要对加载到系统中的数据进行一致性检查。"><a href="#9-10：系统运行之初，要对加载到系统中的数据进行一致性检查。" class="headerlink" title="9-10：系统运行之初，要对加载到系统中的数据进行一致性检查。"></a>9-10：系统运行之初，要对加载到系统中的数据进行一致性检查。</h4><p>说明：使用不一致的数据，容易使系统进入混乱状态和不可知状态。</p>
<h4 id="9-11：严禁随意更改其它模块或系统的有关设置和配置。"><a href="#9-11：严禁随意更改其它模块或系统的有关设置和配置。" class="headerlink" title="9-11：严禁随意更改其它模块或系统的有关设置和配置。"></a>9-11：严禁随意更改其它模块或系统的有关设置和配置。</h4><p>说明：编程时，不能随心所欲地更改不属于自己模块的有关设置如常量、数组的大小等。</p>
<h4 id="9-12：不能随意改变与其它模块的接口。"><a href="#9-12：不能随意改变与其它模块的接口。" class="headerlink" title="9-12：不能随意改变与其它模块的接口。"></a>9-12：不能随意改变与其它模块的接口。</h4><h4 id="9-13：充分了解系统的接口之后，再使用系统提供的功能。"><a href="#9-13：充分了解系统的接口之后，再使用系统提供的功能。" class="headerlink" title="9-13：充分了解系统的接口之后，再使用系统提供的功能。"></a>9-13：充分了解系统的接口之后，再使用系统提供的功能。</h4><p>示例：在B型机的各模块与操作系统的接口函数中，有一个要由各模块负责编写的初始化过程，此过程在软件系统加载完成后，由操作系统发送的初始化消息来调度。因此就涉及到初始化消息的类型与消息发送的顺序问题，特别是消息顺序，若没搞清楚就开始编程，很容易引起严重后果。以下示例引自B型曾出现过的实际代码，其中使用了FID_FETCH_DATA与FID_INITIAL初始化消息类型，注意B型机的系统是在FID_FETCH_DATA之前发送FID_INITIAL的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">MID alarm_module_list[MAX_ALARM_MID];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> FAR <span class="title">SYS_ALARM_proc</span><span class="params">( FID function_id, <span class="keyword">int</span> handle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _UI i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ( function_id )</span><br><span class="line">    &#123;</span><br><span class="line">        ... <span class="comment">// program code</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FID_INITAIL:</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ALARM_MID; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (alarm_module_list[i]== BAM_MODULE <span class="comment">// **）</span></span><br><span class="line">                   || (alarm_module_list[i]== LOCAL_MODULE)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ALARM_CLASS_SUM; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        FAR_MALLOC( ... );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ... <span class="comment">// program code</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">case</span> FID_FETCH_DATA:</span><br><span class="line"></span><br><span class="line">            ... <span class="comment">// program code</span></span><br><span class="line"></span><br><span class="line">            Get_Alarm_Module( );  <span class="comment">// 初始化alarm_module_list</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">// program code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于FID_INITIAL是在FID_FETCH_DATA之前执行的，而初始化alarm_module_list是在FID_FETCH_DATA中进行的，故在FID_INITIAL中（**）处引用alarm_module_list变量时，它还没有被初始化。这是个严重错误。</p>
<p>应如下改正：要么把Get_Alarm_Module函数放在FID_INITIAL中（<strong>）之前；要么就必须考虑（</strong>）处的判断语句是否可以用（不使用alarm_module_list变量的）其它方式替代，或者是否可以取消此判断语句。</p>
<h4 id="9-14：编程时，要防止差1错误。"><a href="#9-14：编程时，要防止差1错误。" class="headerlink" title="9-14：编程时，要防止差1错误。"></a>9-14：编程时，要防止差1错误。</h4><p>说明：此类错误一般是由于把“&lt;=”误写成“&lt;”或“&gt;=”误写成“&gt;”等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。当编完程序后，应对这些操作符进行彻底检查。</p>
<h4 id="9-15：要时刻注意易混淆的操作符。当编完程序后，应从头至尾检查一遍这些操作符，以防止拼写错误。"><a href="#9-15：要时刻注意易混淆的操作符。当编完程序后，应从头至尾检查一遍这些操作符，以防止拼写错误。" class="headerlink" title="9-15：要时刻注意易混淆的操作符。当编完程序后，应从头至尾检查一遍这些操作符，以防止拼写错误。"></a>9-15：要时刻注意易混淆的操作符。当编完程序后，应从头至尾检查一遍这些操作符，以防止拼写错误。</h4><p>说明：形式相近的操作符最容易引起误用，如C/C++中的“=”与“==”、“|”与“||”、“&amp;”与“&amp;&amp;”等，若拼写错了，编译器不一定能够检查出来。</p>
<p>示例：如把“&amp;”写成“&amp;&amp;”，或反之。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret_flg = (pmsg-&gt;ret_flg &amp; RETURN_MASK);</span><br></pre></td></tr></table></figure>
<p>被写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret_flg = (pmsg-&gt;ret_flg &amp;&amp; RETURN_MASK);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpt_flg = (VALID_TASK_NO( taskno ) &amp;&amp; DATA_NOT_ZERO( stat_data ));</span><br></pre></td></tr></table></figure>
<p>被写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpt_flg = (VALID_TASK_NO( taskno ) &amp; DATA_NOT_ZERO( stat_data ));</span><br></pre></td></tr></table></figure>
<h4 id="9-16：有可能的话，if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支。"><a href="#9-16：有可能的话，if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支。" class="headerlink" title="9-16：有可能的话，if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支。"></a>9-16：有可能的话，if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支。</h4><h4 id="9-17：Unix下，多线程的中的子线程退出必需采用主动退出方式，即子线程应return出口。"><a href="#9-17：Unix下，多线程的中的子线程退出必需采用主动退出方式，即子线程应return出口。" class="headerlink" title="9-17：Unix下，多线程的中的子线程退出必需采用主动退出方式，即子线程应return出口。"></a>9-17：Unix下，多线程的中的子线程退出必需采用主动退出方式，即子线程应return出口。</h4><h4 id="9-18：不要滥用goto语句。"><a href="#9-18：不要滥用goto语句。" class="headerlink" title="9-18：不要滥用goto语句。"></a>9-18：不要滥用goto语句。</h4><p>说明：goto语句会破坏程序的结构性，所以除非确实需要，最好不使用goto语句。</p>
<h4 id="½9-1：不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。"><a href="#½9-1：不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。" class="headerlink" title="½9-1：不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。"></a>½9-1：不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。</h4><h4 id="½9-2：除非为了满足特殊需求，避免使用嵌入式汇编。"><a href="#½9-2：除非为了满足特殊需求，避免使用嵌入式汇编。" class="headerlink" title="½9-2：除非为了满足特殊需求，避免使用嵌入式汇编。"></a>½9-2：除非为了满足特殊需求，避免使用嵌入式汇编。</h4><p>说明：程序中嵌入式汇编，一般都对可移植性有较大的影响。</p>
<h4 id="½9-3：精心地构造、划分子模块，并按“接口”部分及“内核”部分合理地组织子模块，以提高“内核”部分的可移植性和可重用性。"><a href="#½9-3：精心地构造、划分子模块，并按“接口”部分及“内核”部分合理地组织子模块，以提高“内核”部分的可移植性和可重用性。" class="headerlink" title="½9-3：精心地构造、划分子模块，并按“接口”部分及“内核”部分合理地组织子模块，以提高“内核”部分的可移植性和可重用性。"></a>½9-3：精心地构造、划分子模块，并按“接口”部分及“内核”部分合理地组织子模块，以提高“内核”部分的可移植性和可重用性。</h4><p>说明：对不同产品中的某个功能相同的模块，若能做到其内核部分完全或基本一致，那么无论对产品的测试、维护，还是对以后产品的升级都会有很大帮助。</p>
<h4 id="½9-4：精心构造算法，并对其性能、效率进行测试。"><a href="#½9-4：精心构造算法，并对其性能、效率进行测试。" class="headerlink" title="½9-4：精心构造算法，并对其性能、效率进行测试。"></a>½9-4：精心构造算法，并对其性能、效率进行测试。</h4><h4 id="½9-5：对较关键的算法最好使用其它算法来确认。"><a href="#½9-5：对较关键的算法最好使用其它算法来确认。" class="headerlink" title="½9-5：对较关键的算法最好使用其它算法来确认。"></a>½9-5：对较关键的算法最好使用其它算法来确认。</h4><h4 id="½9-6：时刻注意表达式是否会上溢、下溢。"><a href="#½9-6：时刻注意表达式是否会上溢、下溢。" class="headerlink" title="½9-6：时刻注意表达式是否会上溢、下溢。"></a>½9-6：时刻注意表达式是否会上溢、下溢。</h4><p>示例：如下程序将造成变量下溢。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> size ;</span><br><span class="line"><span class="keyword">while</span> (size-- &gt;= <span class="number">0</span>) <span class="comment">// 将出现下溢</span></span><br><span class="line">&#123;</span><br><span class="line">    ... <span class="comment">// program code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当size等于0时，再减1不会小于0，而是0xFF，故程序是一个死循环。应如下修改。</p>
<h4 id="½9-7：使用变量时要注意其边界值的情况。"><a href="#½9-7：使用变量时要注意其边界值的情况。" class="headerlink" title="½9-7：使用变量时要注意其边界值的情况。"></a>½9-7：使用变量时要注意其边界值的情况。</h4><p>示例：如C语言中字符型变量，有效值范围为-128到127。故以下表达式的计算存在一定风险。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> chr = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">chr += <span class="number">1</span>; <span class="comment">// 127为chr的边界值，再加1将使chr上溢到-128，而不是128。</span></span><br><span class="line">sum += chr; <span class="comment">// 故sum的结果不是328，而是72。</span></span><br></pre></td></tr></table></figure>
<p>若chr与sum为同一种类型，或表达式按如下方式书写，可能会好些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = sum + chr + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="½9-8：留心程序机器码大小（如指令空间大小、数据空间大小、堆栈空间大小等）是否超出系统有关限制。"><a href="#½9-8：留心程序机器码大小（如指令空间大小、数据空间大小、堆栈空间大小等）是否超出系统有关限制。" class="headerlink" title="½9-8：留心程序机器码大小（如指令空间大小、数据空间大小、堆栈空间大小等）是否超出系统有关限制。"></a>½9-8：留心程序机器码大小（如指令空间大小、数据空间大小、堆栈空间大小等）是否超出系统有关限制。</h4><h4 id="½9-9：为用户提供良好的接口界面，使用户能较充分地了解系统内部运行状态及有关系统出错情况。"><a href="#½9-9：为用户提供良好的接口界面，使用户能较充分地了解系统内部运行状态及有关系统出错情况。" class="headerlink" title="½9-9：为用户提供良好的接口界面，使用户能较充分地了解系统内部运行状态及有关系统出错情况。"></a>½9-9：为用户提供良好的接口界面，使用户能较充分地了解系统内部运行状态及有关系统出错情况。</h4><h4 id="½9-10：系统应具有一定的容错能力，对一些错误事件（如用户误操作等）能进行自动补救。"><a href="#½9-10：系统应具有一定的容错能力，对一些错误事件（如用户误操作等）能进行自动补救。" class="headerlink" title="½9-10：系统应具有一定的容错能力，对一些错误事件（如用户误操作等）能进行自动补救。"></a>½9-10：系统应具有一定的容错能力，对一些错误事件（如用户误操作等）能进行自动补救。</h4><h4 id="½9-11：对一些具有危险性的操作代码（如写硬盘、删数据等）要仔细考虑，防止对数据、硬件等的安全构成危害，以提高系统的安全性。"><a href="#½9-11：对一些具有危险性的操作代码（如写硬盘、删数据等）要仔细考虑，防止对数据、硬件等的安全构成危害，以提高系统的安全性。" class="headerlink" title="½9-11：对一些具有危险性的操作代码（如写硬盘、删数据等）要仔细考虑，防止对数据、硬件等的安全构成危害，以提高系统的安全性。"></a>½9-11：对一些具有危险性的操作代码（如写硬盘、删数据等）要仔细考虑，防止对数据、硬件等的安全构成危害，以提高系统的安全性。</h4><h4 id="½9-12：使用第三方提供的软件开发工具包或控件时，要注意以下几点："><a href="#½9-12：使用第三方提供的软件开发工具包或控件时，要注意以下几点：" class="headerlink" title="½9-12：使用第三方提供的软件开发工具包或控件时，要注意以下几点："></a>½9-12：使用第三方提供的软件开发工具包或控件时，要注意以下几点：</h4><p>（1）充分了解应用接口、使用环境及使用时注意事项。</p>
<p>（2）不能过分相信其正确性。</p>
<p>（3）除非必要，不要使用不熟悉的第三方工具包与控件。</p>
<p>说明：使用工具包与控件，可加快程序开发速度，节省时间，但使用之前一定对它有较充分的了解，同时第三方工具包与控件也有可能存在问题。</p>
<h4 id="½9-13：资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL文件或其它单独的描述文件（如数据库格式）"><a href="#½9-13：资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL文件或其它单独的描述文件（如数据库格式）" class="headerlink" title="½9-13：资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL文件或其它单独的描述文件（如数据库格式）"></a>½9-13：资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL文件或其它单独的描述文件（如数据库格式）</h4><h3 id="10-代码编辑、编译、审查"><a href="#10-代码编辑、编译、审查" class="headerlink" title="10 代码编辑、编译、审查"></a>10 代码编辑、编译、审查</h3><h4 id="10-1：打开编译器的所有告警开关对程序进行编译。"><a href="#10-1：打开编译器的所有告警开关对程序进行编译。" class="headerlink" title="10-1：打开编译器的所有告警开关对程序进行编译。"></a>10-1：打开编译器的所有告警开关对程序进行编译。</h4><h4 id="10-2：在产品软件（项目组）中，要统一编译开关选项。"><a href="#10-2：在产品软件（项目组）中，要统一编译开关选项。" class="headerlink" title="10-2：在产品软件（项目组）中，要统一编译开关选项。"></a>10-2：在产品软件（项目组）中，要统一编译开关选项。</h4><h4 id="10-3：通过代码走读及审查方式对代码进行检查。"><a href="#10-3：通过代码走读及审查方式对代码进行检查。" class="headerlink" title="10-3：通过代码走读及审查方式对代码进行检查。"></a>10-3：通过代码走读及审查方式对代码进行检查。</h4><p>说明：代码走读主要是对程序的编程风格如注释、命名等以及编程时易出错的内容进行检查，可由开发人员自己或开发人员交叉的方式进行；代码审查主要是对程序实现的功能及程序的稳定性、安全性、可靠性等进行检查及评审，可通过自审、交叉审核或指定部门抽查等方式进行。</p>
<h4 id="10-4：测试部测试产品之前，应对代码进行抽查及评审。"><a href="#10-4：测试部测试产品之前，应对代码进行抽查及评审。" class="headerlink" title="10-4：测试部测试产品之前，应对代码进行抽查及评审。"></a>10-4：测试部测试产品之前，应对代码进行抽查及评审。</h4><h4 id="½10-1：编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。"><a href="#½10-1：编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。" class="headerlink" title="½10-1：编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。"></a>½10-1：编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。</h4><h4 id="½10-2：同产品软件（项目组）内，最好使用相同的编辑器，并使用相同的设置选项。"><a href="#½10-2：同产品软件（项目组）内，最好使用相同的编辑器，并使用相同的设置选项。" class="headerlink" title="½10-2：同产品软件（项目组）内，最好使用相同的编辑器，并使用相同的设置选项。"></a>½10-2：同产品软件（项目组）内，最好使用相同的编辑器，并使用相同的设置选项。</h4><p>说明：同一项目组最好采用相同的智能语言编辑器，如Muiti Editor，Visual Editor等，并设计、使用一套缩进宏及注释宏等，将缩进等问题交由编辑器处理。</p>
<h4 id="½10-3：要小心地使用编辑器提供的块拷贝功能编程。"><a href="#½10-3：要小心地使用编辑器提供的块拷贝功能编程。" class="headerlink" title="½10-3：要小心地使用编辑器提供的块拷贝功能编程。"></a>½10-3：要小心地使用编辑器提供的块拷贝功能编程。</h4><p>说明：当某段代码与另一段代码的处理功能相似时，许多开发人员都用编辑器提供的块拷贝功能来完成这段代码的编写。由于程序功能相近，故所使用的变量、采用的表达式等在功能及命名上可能都很相近，所以使用块拷贝时要注意，除了修改相应的程序外，一定要把使用的每个变量仔细查看一遍，以改成正确的。不应指望编译器能查出所有这种错误，比如当使用的是全局变量时，就有可能使某种错误隐藏下来。</p>
<h4 id="½10-4：合理地设计软件系统目录，方便开发人员使用。"><a href="#½10-4：合理地设计软件系统目录，方便开发人员使用。" class="headerlink" title="½10-4：合理地设计软件系统目录，方便开发人员使用。"></a>½10-4：合理地设计软件系统目录，方便开发人员使用。</h4><p>说明：方便、合理的软件系统目录，可提高工作效率。目录构造的原则是方便有关源程序的存储、查询、编译、链接等工作，同时目录中还应具有工作目录—-所有的编译、链接等工作应在此目录中进行，工具目录—-有关文件编辑器、文件查找等工具可存放在此目录中。</p>
<h4 id="½10-5：某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。"><a href="#½10-5：某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。" class="headerlink" title="½10-5：某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。"></a>½10-5：某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。</h4><p>说明：在Borland C/C++中，可用“#pragma  warn”来关掉或打开某些告警。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> warn -rvl <span class="comment">// 关闭告警</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">examples_fun</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">// 程序，但无return语句。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> warn +rvl <span class="comment">// 打开告警</span></span></span><br></pre></td></tr></table></figure>
<p>编译函数examples_fun时本应产生“函数应有返回值”告警，但由于关掉了此告警信息显示，所以编译时将不会产生此告警提示。</p>
<h4 id="½10-6：使用代码检查工具（如C语言用PC-Lint）对源程序检查。"><a href="#½10-6：使用代码检查工具（如C语言用PC-Lint）对源程序检查。" class="headerlink" title="½10-6：使用代码检查工具（如C语言用PC-Lint）对源程序检查。"></a>½10-6：使用代码检查工具（如C语言用PC-Lint）对源程序检查。</h4><h4 id="½10-7：使用软件工具（如-LogiSCOPE）进行代码审查。"><a href="#½10-7：使用软件工具（如-LogiSCOPE）进行代码审查。" class="headerlink" title="½10-7：使用软件工具（如 LogiSCOPE）进行代码审查。"></a>½10-7：使用软件工具（如 LogiSCOPE）进行代码审查。</h4><h3 id="11-代码测试、维护"><a href="#11-代码测试、维护" class="headerlink" title="11 代码测试、维护"></a>11 代码测试、维护</h3><h4 id="11-1：单元测试要求至少达到语句覆盖。"><a href="#11-1：单元测试要求至少达到语句覆盖。" class="headerlink" title="11-1：单元测试要求至少达到语句覆盖。"></a>11-1：单元测试要求至少达到语句覆盖。</h4><h4 id="11-2：单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。"><a href="#11-2：单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。" class="headerlink" title="11-2：单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。"></a>11-2：单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。</h4><h4 id="11-3：清理、整理或优化后的代码要经过审查及测试。"><a href="#11-3：清理、整理或优化后的代码要经过审查及测试。" class="headerlink" title="11-3：清理、整理或优化后的代码要经过审查及测试。"></a>11-3：清理、整理或优化后的代码要经过审查及测试。</h4><h4 id="11-4：代码版本升级要经过严格测试。"><a href="#11-4：代码版本升级要经过严格测试。" class="headerlink" title="11-4：代码版本升级要经过严格测试。"></a>11-4：代码版本升级要经过严格测试。</h4><h4 id="11-5：使用工具软件对代码版本进行维护。"><a href="#11-5：使用工具软件对代码版本进行维护。" class="headerlink" title="11-5：使用工具软件对代码版本进行维护。"></a>11-5：使用工具软件对代码版本进行维护。</h4><h4 id="11-6：正式版本上软件的任何修改都应有详细的文档记录。"><a href="#11-6：正式版本上软件的任何修改都应有详细的文档记录。" class="headerlink" title="11-6：正式版本上软件的任何修改都应有详细的文档记录。"></a>11-6：正式版本上软件的任何修改都应有详细的文档记录。</h4><h4 id="½11-1：发现错误立即修改，并且要记录下来。"><a href="#½11-1：发现错误立即修改，并且要记录下来。" class="headerlink" title="½11-1：发现错误立即修改，并且要记录下来。"></a>½11-1：发现错误立即修改，并且要记录下来。</h4><h4 id="½11-2：关键的代码在汇编级跟踪。"><a href="#½11-2：关键的代码在汇编级跟踪。" class="headerlink" title="½11-2：关键的代码在汇编级跟踪。"></a>½11-2：关键的代码在汇编级跟踪。</h4><h4 id="½11-3：仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。"><a href="#½11-3：仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。" class="headerlink" title="½11-3：仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。"></a>½11-3：仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。</h4><h4 id="½11-4：尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。"><a href="#½11-4：尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。" class="headerlink" title="½11-4：尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。"></a>½11-4：尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。</h4><h4 id="½11-5：仔细测试代码处理数据、变量的边界情况。"><a href="#½11-5：仔细测试代码处理数据、变量的边界情况。" class="headerlink" title="½11-5：仔细测试代码处理数据、变量的边界情况。"></a>½11-5：仔细测试代码处理数据、变量的边界情况。</h4><h4 id="½11-6：保留测试信息，以便分析、总结经验及进行更充分的测试。"><a href="#½11-6：保留测试信息，以便分析、总结经验及进行更充分的测试。" class="headerlink" title="½11-6：保留测试信息，以便分析、总结经验及进行更充分的测试。"></a>½11-6：保留测试信息，以便分析、总结经验及进行更充分的测试。</h4><h4 id="½11-7：不应通过“试”来解决问题，应寻找问题的根本原因。"><a href="#½11-7：不应通过“试”来解决问题，应寻找问题的根本原因。" class="headerlink" title="½11-7：不应通过“试”来解决问题，应寻找问题的根本原因。"></a>½11-7：不应通过“试”来解决问题，应寻找问题的根本原因。</h4><h4 id="½11-8：对自动消失的错误进行分析，搞清楚错误是如何消失的。"><a href="#½11-8：对自动消失的错误进行分析，搞清楚错误是如何消失的。" class="headerlink" title="½11-8：对自动消失的错误进行分析，搞清楚错误是如何消失的。"></a>½11-8：对自动消失的错误进行分析，搞清楚错误是如何消失的。</h4><h4 id="½11-9：修改错误不仅要治表，更要治本。"><a href="#½11-9：修改错误不仅要治表，更要治本。" class="headerlink" title="½11-9：修改错误不仅要治表，更要治本。"></a>½11-9：修改错误不仅要治表，更要治本。</h4><h4 id="½11-10：测试时应设法使很少发生的事件经常发生。"><a href="#½11-10：测试时应设法使很少发生的事件经常发生。" class="headerlink" title="½11-10：测试时应设法使很少发生的事件经常发生。"></a>½11-10：测试时应设法使很少发生的事件经常发生。</h4><h4 id="½11-11：明确模块或函数处理哪些事件，并使它们经常发生。"><a href="#½11-11：明确模块或函数处理哪些事件，并使它们经常发生。" class="headerlink" title="½11-11：明确模块或函数处理哪些事件，并使它们经常发生。"></a>½11-11：明确模块或函数处理哪些事件，并使它们经常发生。</h4><h4 id="½11-12：-坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题。"><a href="#½11-12：-坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题。" class="headerlink" title="½11-12： 坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题。"></a>½11-12： 坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题。</h4><h4 id="½11-13：去除代码运行的随机性（如去掉无用的数据、代码及尽可能防止并注意函数中的“内部寄存器”等），让函数运行的结果可预测，并使出现的错误可再现。"><a href="#½11-13：去除代码运行的随机性（如去掉无用的数据、代码及尽可能防止并注意函数中的“内部寄存器”等），让函数运行的结果可预测，并使出现的错误可再现。" class="headerlink" title="½11-13：去除代码运行的随机性（如去掉无用的数据、代码及尽可能防止并注意函数中的“内部寄存器”等），让函数运行的结果可预测，并使出现的错误可再现。"></a>½11-13：去除代码运行的随机性（如去掉无用的数据、代码及尽可能防止并注意函数中的“内部寄存器”等），让函数运行的结果可预测，并使出现的错误可再现。</h4><h3 id="12-宏"><a href="#12-宏" class="headerlink" title="12 宏"></a>12 宏</h3><h4 id="12-1：用宏定义表达式时，要使用完备的括号。"><a href="#12-1：用宏定义表达式时，要使用完备的括号。" class="headerlink" title="12-1：用宏定义表达式时，要使用完备的括号。"></a>12-1：用宏定义表达式时，要使用完备的括号。</h4><p>示例：如下定义的宏都存在一定的风险。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_AREA( a, b ) a * b</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_AREA( a, b ) (a * b)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_AREA( a, b ) (a) * (b)</span></span><br></pre></td></tr></table></figure>
<p>正确的定义应为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_AREA( a, b ) ((a) * (b))</span></span><br></pre></td></tr></table></figure>
<h4 id="12-2-将宏所定义的多条表达式放在大括号中"><a href="#12-2-将宏所定义的多条表达式放在大括号中" class="headerlink" title="12-2:将宏所定义的多条表达式放在大括号中"></a>12-2:将宏所定义的多条表达式放在大括号中</h4><p>示例：下面的语句只有宏的第一条表达式被执行。为了说明问题，for语句的书写稍不符规范。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTI_RECT_VALUE( a, b )\</span></span><br><span class="line">    a = <span class="number">0</span>;\</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; RECT_TOTAL_NUM; index++)</span><br><span class="line">    INTI_RECT_VALUE( rect.a, rect.b );</span><br></pre></td></tr></table></figure>
<p>正确的用法应为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTI_RECT_VALUE( a, b )\</span></span><br><span class="line">&#123;\</span><br><span class="line">    a = <span class="number">0</span>;\</span><br><span class="line">    b = <span class="number">0</span>;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; RECT_TOTAL_NUM; index++)</span><br><span class="line">&#123;</span><br><span class="line">   INTI_RECT_VALUE( rect[index].a, rect[index].b );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-3-使用宏时，不允许参数发生变化。"><a href="#12-3-使用宏时，不允许参数发生变化。" class="headerlink" title="12-3:使用宏时，不允许参数发生变化。"></a>12-3:使用宏时，不允许参数发生变化。</h4><p>示例：如下用法可能导致错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE( a ) ((a) * (a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">b = SQUARE( a++ ); <span class="comment">// 结果：a = 7，即执行了两次增1。</span></span><br></pre></td></tr></table></figure>
<p>正确的用法是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = SQUARE( a );</span><br><span class="line"></span><br><span class="line">a++; <span class="comment">// 结果：a = 6，即只执行了一次增1。</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2020/02/24/hw-code-style-guide/">华为软件编程规范和范例</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">焦迪</a></p>
        <p><span>发布时间:</span>2020-02-24, 21:25:06</p>
        <p><span>最后更新:</span>2020-02-29, 13:36:25</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2020/02/24/hw-code-style-guide/" title="华为软件编程规范和范例">http://jiaodi.tech/2020/02/24/hw-code-style-guide/</a>
            <span class="copy-path" data-clipboard-text="原文: http://jiaodi.tech/2020/02/24/hw-code-style-guide/　　作者: 焦迪" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target="_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2020/02/29/git-flow/">
                    Git 分支管理
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/11/09/ATECC508A-config/">
                    ATECC508A配置案例
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#华为软件编程规范和范例"><span class="toc-number">1.</span> <span class="toc-text">华为软件编程规范和范例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-排版"><span class="toc-number">1.1.</span> <span class="toc-text">1 排版</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1：程序块要采用缩进风格编写，缩进的空格数为4个。"><span class="toc-number">1.1.1.</span> <span class="toc-text">1-1：程序块要采用缩进风格编写，缩进的空格数为4个。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2：相对独立的程序块之间、变量说明之后必须加空行。"><span class="toc-number">1.1.2.</span> <span class="toc-text">1-2：相对独立的程序块之间、变量说明之后必须加空行。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3：较长的语句（-gt-80字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。"><span class="toc-number">1.1.3.</span> <span class="toc-text">1-3：较长的语句（&gt;80字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4：循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分，长表达式要在低优先级操作符处划分新行，操作符放在新行之首。"><span class="toc-number">1.1.4.</span> <span class="toc-text">1-4：循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分，长表达式要在低优先级操作符处划分新行，操作符放在新行之首。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5：若函数或过程中的参数较长，则要进行适当的划分。"><span class="toc-number">1.1.5.</span> <span class="toc-text">1-5：若函数或过程中的参数较长，则要进行适当的划分。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6：不允许把多个短语句写在一行中，即一行只写一条语句。"><span class="toc-number">1.1.6.</span> <span class="toc-text">1-6：不允许把多个短语句写在一行中，即一行只写一条语句。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7：if、for、do、while、case、switch、default等语句自占一行，且if、for、do、while等语句的执行语句部分无论多少都要加括号-。"><span class="toc-number">1.1.7.</span> <span class="toc-text">1-7：if、for、do、while、case、switch、default等语句自占一行，且if、for、do、while等语句的执行语句部分无论多少都要加括号{}。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8：对齐只使用空格键，不使用TAB键。"><span class="toc-number">1.1.8.</span> <span class="toc-text">1-8：对齐只使用空格键，不使用TAB键。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9：函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格，case语句下的情况处理语句也要遵从语句缩进要求。"><span class="toc-number">1.1.9.</span> <span class="toc-text">1-9：函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格，case语句下的情况处理语句也要遵从语句缩进要求。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10：程序块的分界符（如C-C-语言的大括号‘-’和‘-’）应各独占一行并且位于同一列，同时与引用它们的语句左对齐。在函数体的开始、类的定义、结构的定义、枚举的定义以及if、for、do、while、switch、case语句中的程序都要采用如上的缩进方式。"><span class="toc-number">1.1.10.</span> <span class="toc-text">1-10：程序块的分界符（如C/C++语言的大括号‘{’和‘}’）应各独占一行并且位于同一列，同时与引用它们的语句左对齐。在函数体的开始、类的定义、结构的定义、枚举的定义以及if、for、do、while、switch、case语句中的程序都要采用如上的缩进方式。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11：在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－-gt-），后不应加空格。"><span class="toc-number">1.1.11.</span> <span class="toc-text">1-11：在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－&gt;），后不应加空格。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½1-1：一行程序以小于80字符为宜，不要写得过长。"><span class="toc-number">1.1.12.</span> <span class="toc-text">½1-1：一行程序以小于80字符为宜，不要写得过长。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-注释"><span class="toc-number">1.2.</span> <span class="toc-text">2 注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1：一般情况下，源程序有效注释量必须在20％以上。"><span class="toc-number">1.2.1.</span> <span class="toc-text">2-1：一般情况下，源程序有效注释量必须在20％以上。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2：说明性文件（如头文件-h文件、-inc文件、-def文件、编译说明文件-cfg等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。"><span class="toc-number">1.2.2.</span> <span class="toc-text">2-2：说明性文件（如头文件.h文件、.inc文件、.def文件、编译说明文件.cfg等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3：源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的-功能、主要函数及其功能、修改日志等。"><span class="toc-number">1.2.3.</span> <span class="toc-text">2-3：源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的/功能、主要函数及其功能、修改日志等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4：函数头部应进行注释，列出：函数的目的-功能、输入参数、输出参数、返回值、调用关系（函数、表）等。"><span class="toc-number">1.2.4.</span> <span class="toc-text">2-4：函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5：边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。"><span class="toc-number">1.2.5.</span> <span class="toc-text">2-5：边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6：注释的内容要清楚、明了，含义准确，防止注释二义性。"><span class="toc-number">1.2.6.</span> <span class="toc-text">2-6：注释的内容要清楚、明了，含义准确，防止注释二义性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7：避免在注释中使用缩写，特别是非常用缩写。"><span class="toc-number">1.2.7.</span> <span class="toc-text">2-7：避免在注释中使用缩写，特别是非常用缩写。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8：注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。"><span class="toc-number">1.2.8.</span> <span class="toc-text">2-8：注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9：对于所有有物理含义的变量、常量，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其物理含义。变量、常量、宏的注释应放在其上方相邻位置或右方。"><span class="toc-number">1.2.9.</span> <span class="toc-text">2-9：对于所有有物理含义的变量、常量，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其物理含义。变量、常量、宏的注释应放在其上方相邻位置或右方。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10：数据结构声明-包括数组、结构、类、枚举等-，如果其命名不是充分自注释的，必须加以注释。对数据结构的注释应放在其上方相邻位置，不可放在下面；对结构中的每个域的注释放在此域的右方。"><span class="toc-number">1.2.10.</span> <span class="toc-text">2-10：数据结构声明(包括数组、结构、类、枚举等)，如果其命名不是充分自注释的，必须加以注释。对数据结构的注释应放在其上方相邻位置，不可放在下面；对结构中的每个域的注释放在此域的右方。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11：全局变量要有较详细的注释，包括对其功能、取值范围、哪些函数或过程存取它以及存取时注意事项等的说明。"><span class="toc-number">1.2.11.</span> <span class="toc-text">2-11：全局变量要有较详细的注释，包括对其功能、取值范围、哪些函数或过程存取它以及存取时注意事项等的说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12：注释与所描述内容进行同样的缩排。"><span class="toc-number">1.2.12.</span> <span class="toc-text">2-12：注释与所描述内容进行同样的缩排。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-13：将注释与其上面的代码用空行隔开。"><span class="toc-number">1.2.13.</span> <span class="toc-text">2-13：将注释与其上面的代码用空行隔开。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-14：对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。"><span class="toc-number">1.2.14.</span> <span class="toc-text">2-14：对变量的定义和分支语句（条件分支、循环语句等）必须编写注释。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-15：对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。"><span class="toc-number">1.2.15.</span> <span class="toc-text">2-15：对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½2-1：避免在一行代码或表达式的中间插入注释。"><span class="toc-number">1.2.16.</span> <span class="toc-text">½2-1：避免在一行代码或表达式的中间插入注释。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½2-2：通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。"><span class="toc-number">1.2.17.</span> <span class="toc-text">½2-2：通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½2-3：在代码的功能、意图层次上进行注释，提供有用、额外的信息。"><span class="toc-number">1.2.18.</span> <span class="toc-text">½2-3：在代码的功能、意图层次上进行注释，提供有用、额外的信息。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½2-4：在程序块的结束行右方加注释标记，以表明某程序块的结束。"><span class="toc-number">1.2.19.</span> <span class="toc-text">½2-4：在程序块的结束行右方加注释标记，以表明某程序块的结束。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½2-5：注释格式尽量统一，建议使用“-……-”。"><span class="toc-number">1.2.20.</span> <span class="toc-text">½2-5：注释格式尽量统一，建议使用“/ …… /”。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½2-6：注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。"><span class="toc-number">1.2.21.</span> <span class="toc-text">½2-6：注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-标识符命名"><span class="toc-number">1.3.</span> <span class="toc-text">3 标识符命名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1：标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。"><span class="toc-number">1.3.1.</span> <span class="toc-text">3-1：标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2：命名中若使用特殊约定或缩写，则要有注释说明。"><span class="toc-number">1.3.2.</span> <span class="toc-text">3-2：命名中若使用特殊约定或缩写，则要有注释说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3：自己特有的命名风格，要自始至终保持一致，不可来回变化。"><span class="toc-number">1.3.3.</span> <span class="toc-text">3-3：自己特有的命名风格，要自始至终保持一致，不可来回变化。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4：对于变量命名，禁止取单个字符（如i、j、k…），建议除了要有具体含义外，还能表明其变量类型、数据类型等，但i、j、k作局部循环变量是允许的。"><span class="toc-number">1.3.4.</span> <span class="toc-text">3-4：对于变量命名，禁止取单个字符（如i、j、k…），建议除了要有具体含义外，还能表明其变量类型、数据类型等，但i、j、k作局部循环变量是允许的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5：命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用UNIX的全小写加下划线的风格或大小写混排的方式，不要使用大小写与下划线混排的方式，用作特殊标识如标识成员变量或全局变量的m-和g-，其后加上大小写混排的方式是允许的。"><span class="toc-number">1.3.5.</span> <span class="toc-text">3-5：命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用UNIX的全小写加下划线的风格或大小写混排的方式，不要使用大小写与下划线混排的方式，用作特殊标识如标识成员变量或全局变量的m_和g_，其后加上大小写混排的方式是允许的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½3-1：除非必要，不要用数字或较奇怪的字符来定义标识符。"><span class="toc-number">1.3.6.</span> <span class="toc-text">½3-1：除非必要，不要用数字或较奇怪的字符来定义标识符。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½3-2：在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突。"><span class="toc-number">1.3.7.</span> <span class="toc-text">½3-2：在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½3-3：用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。"><span class="toc-number">1.3.8.</span> <span class="toc-text">½3-3：用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½3-4：除了编译开关-头文件等特殊应用，应避免使用-EXAMPLE-TEST-之类以下划线开始和结尾的定义。"><span class="toc-number">1.3.9.</span> <span class="toc-text">½3-4：除了编译开关/头文件等特殊应用，应避免使用_EXAMPLE_TEST_之类以下划线开始和结尾的定义。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-可读性"><span class="toc-number">1.4.</span> <span class="toc-text">4 可读性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1：注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级。"><span class="toc-number">1.4.1.</span> <span class="toc-text">4-1：注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2：避免使用不易理解的数字，用有意义的标识来替代。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。"><span class="toc-number">1.4.2.</span> <span class="toc-text">4-2：避免使用不易理解的数字，用有意义的标识来替代。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½4-1：源程序中关系较为紧密的代码应尽可能相邻。"><span class="toc-number">1.4.3.</span> <span class="toc-text">½4-1：源程序中关系较为紧密的代码应尽可能相邻。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½4-2：不要使用难懂的技巧性很高的语句，除非很有必要时。"><span class="toc-number">1.4.4.</span> <span class="toc-text">½4-2：不要使用难懂的技巧性很高的语句，除非很有必要时。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-变量、结构"><span class="toc-number">1.5.</span> <span class="toc-text">5 变量、结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1：去掉没必要的公共变量。"><span class="toc-number">1.5.1.</span> <span class="toc-text">5-1：去掉没必要的公共变量。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2：仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系。"><span class="toc-number">1.5.2.</span> <span class="toc-text">5-2：仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3：明确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。"><span class="toc-number">1.5.3.</span> <span class="toc-text">5-3：明确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4：当向公共变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。"><span class="toc-number">1.5.4.</span> <span class="toc-text">5-4：当向公共变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5：防止局部变量与公共变量同名。"><span class="toc-number">1.5.5.</span> <span class="toc-text">5-5：防止局部变量与公共变量同名。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6：严禁使用未经初始化的变量作为右值。"><span class="toc-number">1.5.6.</span> <span class="toc-text">5-6：严禁使用未经初始化的变量作为右值。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-1：构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的公共变量，防止多个不同模块或函数都可以修改、创建同一公共变量的现象。"><span class="toc-number">1.5.7.</span> <span class="toc-text">½5-1：构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的公共变量，防止多个不同模块或函数都可以修改、创建同一公共变量的现象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-2：使用严格形式定义的、可移植的数据类型，尽量不要使用与具体硬件或软件环境关系密切的变量。"><span class="toc-number">1.5.8.</span> <span class="toc-text">½5-2：使用严格形式定义的、可移植的数据类型，尽量不要使用与具体硬件或软件环境关系密切的变量。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-3：结构的功能要单一，是针对一种事务的抽象。"><span class="toc-number">1.5.9.</span> <span class="toc-text">½5-3：结构的功能要单一，是针对一种事务的抽象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-4：不要设计面面俱到、非常灵活的数据结构。"><span class="toc-number">1.5.10.</span> <span class="toc-text">½5-4：不要设计面面俱到、非常灵活的数据结构。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-5：不同结构间的关系不要过于复杂。"><span class="toc-number">1.5.11.</span> <span class="toc-text">½5-5：不同结构间的关系不要过于复杂。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-6：结构中元素的个数应适中。若结构中元素个数过多可考虑依据某种原则把元素组成不同的子结构，以减少原结构中元素的个数。"><span class="toc-number">1.5.12.</span> <span class="toc-text">½5-6：结构中元素的个数应适中。若结构中元素个数过多可考虑依据某种原则把元素组成不同的子结构，以减少原结构中元素的个数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-7：仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象。"><span class="toc-number">1.5.13.</span> <span class="toc-text">½5-7：仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-8：结构的设计要尽量考虑向前兼容和以后的版本升级，并为某些未来可能的应用保留余地（如预留一些空间等）。"><span class="toc-number">1.5.14.</span> <span class="toc-text">½5-8：结构的设计要尽量考虑向前兼容和以后的版本升级，并为某些未来可能的应用保留余地（如预留一些空间等）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-9：留心具体语言及编译器处理不同数据类型的原则及有关细节。"><span class="toc-number">1.5.15.</span> <span class="toc-text">½5-9：留心具体语言及编译器处理不同数据类型的原则及有关细节。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-10：编程时，要注意数据类型的强制转换。"><span class="toc-number">1.5.16.</span> <span class="toc-text">½5-10：编程时，要注意数据类型的强制转换。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-11：对编译系统默认的数据类型转换，也要有充分的认识。"><span class="toc-number">1.5.17.</span> <span class="toc-text">½5-11：对编译系统默认的数据类型转换，也要有充分的认识。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-12：尽量减少没有必要的数据类型默认转换与强制转换。"><span class="toc-number">1.5.18.</span> <span class="toc-text">½5-12：尽量减少没有必要的数据类型默认转换与强制转换。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-13：合理地设计数据并使用自定义数据类型，避免数据间进行不必要的类型转换。"><span class="toc-number">1.5.19.</span> <span class="toc-text">½5-13：合理地设计数据并使用自定义数据类型，避免数据间进行不必要的类型转换。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-14：对自定义数据类型进行恰当命名，使它成为自描述性的，以提高代码可读性。注意其命名方式在同一产品中的统一。"><span class="toc-number">1.5.20.</span> <span class="toc-text">½5-14：对自定义数据类型进行恰当命名，使它成为自描述性的，以提高代码可读性。注意其命名方式在同一产品中的统一。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½5-15：当声明用于分布式环境或不同CPU间通信环境的数据结构时，必须考虑机器的字节顺序、使用的位域及字节对齐等问题-。"><span class="toc-number">1.5.21.</span> <span class="toc-text">½5-15：当声明用于分布式环境或不同CPU间通信环境的数据结构时，必须考虑机器的字节顺序、使用的位域及字节对齐等问题 。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-函数、过程"><span class="toc-number">1.6.</span> <span class="toc-text">6 函数、过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1：对所调用函数的错误返回码要仔细、全面地处理。"><span class="toc-number">1.6.1.</span> <span class="toc-text">6-1：对所调用函数的错误返回码要仔细、全面地处理。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2：明确函数功能，精确（而不是近似）地实现函数设计。"><span class="toc-number">1.6.2.</span> <span class="toc-text">6-2：明确函数功能，精确（而不是近似）地实现函数设计。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3：编写可重入函数时，应注意局部变量的使用（如编写C-C-语言的可重入函数时，应使用auto即缺省态局部变量或寄存器变量）。"><span class="toc-number">1.6.3.</span> <span class="toc-text">6-3：编写可重入函数时，应注意局部变量的使用（如编写C/C++语言的可重入函数时，应使用auto即缺省态局部变量或寄存器变量）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4：编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。"><span class="toc-number">1.6.4.</span> <span class="toc-text">6-4：编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即P、V操作）等手段对其加以保护。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5：在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。"><span class="toc-number">1.6.5.</span> <span class="toc-text">6-5：在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-1：防止将函数的参数作为工作变量。"><span class="toc-number">1.6.6.</span> <span class="toc-text">½6-1：防止将函数的参数作为工作变量。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-2：函数的规模尽量限制在200行以内。"><span class="toc-number">1.6.7.</span> <span class="toc-text">½6-2：函数的规模尽量限制在200行以内。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-3：一个函数仅完成一件功能。"><span class="toc-number">1.6.8.</span> <span class="toc-text">½6-3：一个函数仅完成一件功能。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-4：为简单功能编写函数。"><span class="toc-number">1.6.9.</span> <span class="toc-text">½6-4：为简单功能编写函数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-5：不要设计多用途面面俱到的函数。"><span class="toc-number">1.6.10.</span> <span class="toc-text">½6-5：不要设计多用途面面俱到的函数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-6：函数的功能应该是可以预测的，也就是只要输入数据相同就应产生同样的输出。"><span class="toc-number">1.6.11.</span> <span class="toc-text">½6-6：函数的功能应该是可以预测的，也就是只要输入数据相同就应产生同样的输出。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-7：尽量不要编写依赖于其他函数内部实现的函数。"><span class="toc-number">1.6.12.</span> <span class="toc-text">½6-7：尽量不要编写依赖于其他函数内部实现的函数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-8：避免设计多参数函数，不使用的参数从接口中去掉。"><span class="toc-number">1.6.13.</span> <span class="toc-text">½6-8：避免设计多参数函数，不使用的参数从接口中去掉。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-9：非调度函数应减少或防止控制参数，尽量只使用数据参数。"><span class="toc-number">1.6.14.</span> <span class="toc-text">½6-9：非调度函数应减少或防止控制参数，尽量只使用数据参数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-10：检查函数所有参数输入的有效性。"><span class="toc-number">1.6.15.</span> <span class="toc-text">½6-10：检查函数所有参数输入的有效性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-11：检查函数所有非参数输入的有效性，如数据文件、公共变量等。"><span class="toc-number">1.6.16.</span> <span class="toc-text">½6-11：检查函数所有非参数输入的有效性，如数据文件、公共变量等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-12：函数名应准确描述函数的功能。"><span class="toc-number">1.6.17.</span> <span class="toc-text">½6-12：函数名应准确描述函数的功能。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-13：使用动宾词组为执行某操作的函数命名。如果是OOP方法，可以只有动词（名词是对象本身）。"><span class="toc-number">1.6.18.</span> <span class="toc-text">½6-13：使用动宾词组为执行某操作的函数命名。如果是OOP方法，可以只有动词（名词是对象本身）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-14：避免使用无意义或含义不清的动词为函数命名。"><span class="toc-number">1.6.19.</span> <span class="toc-text">½6-14：避免使用无意义或含义不清的动词为函数命名。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-15：函数的返回值要清楚、明了，让使用者不容易忽视错误情况。"><span class="toc-number">1.6.20.</span> <span class="toc-text">½6-15：函数的返回值要清楚、明了，让使用者不容易忽视错误情况。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-16：除非必要，最好不要把与函数返回值类型不同的变量，以编译系统默认的转换方式或强制的转换方式作为返回值返回。"><span class="toc-number">1.6.21.</span> <span class="toc-text">½6-16：除非必要，最好不要把与函数返回值类型不同的变量，以编译系统默认的转换方式或强制的转换方式作为返回值返回。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-17：让函数在调用点显得易懂、容易理解。"><span class="toc-number">1.6.22.</span> <span class="toc-text">½6-17：让函数在调用点显得易懂、容易理解。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-18：在调用函数填写参数时，应尽量减少没有必要的默认数据类型转换或强制数据类型转换。"><span class="toc-number">1.6.23.</span> <span class="toc-text">½6-18：在调用函数填写参数时，应尽量减少没有必要的默认数据类型转换或强制数据类型转换。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-19：避免函数中不必要语句，防止程序中的垃圾代码。"><span class="toc-number">1.6.24.</span> <span class="toc-text">½6-19：避免函数中不必要语句，防止程序中的垃圾代码。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-20：防止把没有关联的语句放到一个函数中。"><span class="toc-number">1.6.25.</span> <span class="toc-text">½6-20：防止把没有关联的语句放到一个函数中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-21：如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题。"><span class="toc-number">1.6.26.</span> <span class="toc-text">½6-21：如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-22：功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。"><span class="toc-number">1.6.27.</span> <span class="toc-text">½6-22：功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-23：设计高扇入、合理扇出（小于7）的函数。"><span class="toc-number">1.6.28.</span> <span class="toc-text">½6-23：设计高扇入、合理扇出（小于7）的函数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-24：减少函数本身或函数间的递归调用。"><span class="toc-number">1.6.29.</span> <span class="toc-text">½6-24：减少函数本身或函数间的递归调用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-25：仔细分析模块的功能及性能需求，并进一步细分，同时若有必要画出有关数据流图，据此来进行模块的函数划分与组织。"><span class="toc-number">1.6.30.</span> <span class="toc-text">½6-25：仔细分析模块的功能及性能需求，并进一步细分，同时若有必要画出有关数据流图，据此来进行模块的函数划分与组织。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-26：改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性以及代码可读性、效率和可维护性。优化函数结构时，要遵守以下原则："><span class="toc-number">1.6.31.</span> <span class="toc-text">½6-26：改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性以及代码可读性、效率和可维护性。优化函数结构时，要遵守以下原则：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-27：在多任务操作系统的环境下编程，要注意函数可重入性的构造。"><span class="toc-number">1.6.32.</span> <span class="toc-text">½6-27：在多任务操作系统的环境下编程，要注意函数可重入性的构造。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-28：避免使用BOOL参数。"><span class="toc-number">1.6.33.</span> <span class="toc-text">½6-28：避免使用BOOL参数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-29：-对于提供了返回值的函数，在引用时最好使用其返回值。"><span class="toc-number">1.6.34.</span> <span class="toc-text">½6-29： 对于提供了返回值的函数，在引用时最好使用其返回值。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½6-30：当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。"><span class="toc-number">1.6.35.</span> <span class="toc-text">½6-30：当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-可测性"><span class="toc-number">1.7.</span> <span class="toc-text">7 可测性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1：在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。"><span class="toc-number">1.7.1.</span> <span class="toc-text">7-1：在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2：在同一项目组或产品组内，调测打印出的信息串的格式要有统一的形式。信息串中至少要有所在模块名（或源文件名）及行号。"><span class="toc-number">1.7.2.</span> <span class="toc-text">7-2：在同一项目组或产品组内，调测打印出的信息串的格式要有统一的形式。信息串中至少要有所在模块名（或源文件名）及行号。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3：编程的同时要为单元测试选择恰当的测试点，并仔细构造测试代码、测试用例，同时给出明确的注释说明。测试代码部分应作为（模块中的）一个子模块，以方便测试代码在模块中的安装与拆卸（通过调测开关）。"><span class="toc-number">1.7.3.</span> <span class="toc-text">7-3：编程的同时要为单元测试选择恰当的测试点，并仔细构造测试代码、测试用例，同时给出明确的注释说明。测试代码部分应作为（模块中的）一个子模块，以方便测试代码在模块中的安装与拆卸（通过调测开关）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4：在进行集成测试-系统联调之前，要构造好测试环境、测试项目及测试用例，同时仔细分析并优化测试用例，以提高测试效率。"><span class="toc-number">1.7.4.</span> <span class="toc-text">7-4：在进行集成测试/系统联调之前，要构造好测试环境、测试项目及测试用例，同时仔细分析并优化测试用例，以提高测试效率。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5：使用断言来发现软件问题，提高代码可测性。"><span class="toc-number">1.7.5.</span> <span class="toc-text">7-5：使用断言来发现软件问题，提高代码可测性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6：用断言来检查程序正常运行时不应发生但在调测时有可能发生的非法情况。"><span class="toc-number">1.7.6.</span> <span class="toc-text">7-6：用断言来检查程序正常运行时不应发生但在调测时有可能发生的非法情况。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7：不能用断言来检查最终产品肯定会出现且必须处理的错误情况。"><span class="toc-number">1.7.7.</span> <span class="toc-text">7-7：不能用断言来检查最终产品肯定会出现且必须处理的错误情况。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8：对较复杂的断言加上明确的注释。"><span class="toc-number">1.7.8.</span> <span class="toc-text">7-8：对较复杂的断言加上明确的注释。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9：用断言确认函数的参数。"><span class="toc-number">1.7.9.</span> <span class="toc-text">7-9：用断言确认函数的参数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-10：用断言保证没有定义的特性或功能不被使用。"><span class="toc-number">1.7.10.</span> <span class="toc-text">7-10：用断言保证没有定义的特性或功能不被使用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-11：用断言对程序开发环境（OS-Compiler-Hardware）的假设进行检查。"><span class="toc-number">1.7.11.</span> <span class="toc-text">7-11：用断言对程序开发环境（OS/Compiler/Hardware）的假设进行检查。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-12：正式软件产品中应把断言及其它调测代码去掉（即把有关的调测开关关掉）。"><span class="toc-number">1.7.12.</span> <span class="toc-text">7-12：正式软件产品中应把断言及其它调测代码去掉（即把有关的调测开关关掉）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-13：在软件系统中设置与取消有关测试手段，不能对软件实现的功能等产生影响。"><span class="toc-number">1.7.13.</span> <span class="toc-text">7-13：在软件系统中设置与取消有关测试手段，不能对软件实现的功能等产生影响。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-14：用调测开关来切换软件的DEBUG版和正式版，而不要同时存在正式版本和DEBUG版本的不同源文件，以减少维护的难度。"><span class="toc-number">1.7.14.</span> <span class="toc-text">7-14：用调测开关来切换软件的DEBUG版和正式版，而不要同时存在正式版本和DEBUG版本的不同源文件，以减少维护的难度。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-15：软件的DEBUG版本和发行版本应该统一维护，不允许分家，并且要时刻注意保证两个版本在实现功能上的一致性。"><span class="toc-number">1.7.15.</span> <span class="toc-text">7-15：软件的DEBUG版本和发行版本应该统一维护，不允许分家，并且要时刻注意保证两个版本在实现功能上的一致性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½7-1：在编写代码之前，应预先设计好程序调试与测试的方法和手段，并设计好各种调测开关及相应测试代码如打印函数等。"><span class="toc-number">1.7.16.</span> <span class="toc-text">½7-1：在编写代码之前，应预先设计好程序调试与测试的方法和手段，并设计好各种调测开关及相应测试代码如打印函数等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½7-2：调测开关应分为不同级别和类型。"><span class="toc-number">1.7.17.</span> <span class="toc-text">½7-2：调测开关应分为不同级别和类型。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½7-3：编写防错程序，然后在处理错误之后可用断言宣布发生错误。"><span class="toc-number">1.7.18.</span> <span class="toc-text">½7-3：编写防错程序，然后在处理错误之后可用断言宣布发生错误。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-程序效率"><span class="toc-number">1.8.</span> <span class="toc-text">8 程序效率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1：编程时要经常注意代码的效率。"><span class="toc-number">1.8.1.</span> <span class="toc-text">8-1：编程时要经常注意代码的效率。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2：在保证软件系统的正确性、稳定性、可读性及可测性的前提下，提高代码效率。"><span class="toc-number">1.8.2.</span> <span class="toc-text">8-2：在保证软件系统的正确性、稳定性、可读性及可测性的前提下，提高代码效率。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3：局部效率应为全局效率服务，不能因为提高局部效率而对全局效率造成影响。"><span class="toc-number">1.8.3.</span> <span class="toc-text">8-3：局部效率应为全局效率服务，不能因为提高局部效率而对全局效率造成影响。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4：通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。"><span class="toc-number">1.8.4.</span> <span class="toc-text">8-4：通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5：循环体内工作量最小化。"><span class="toc-number">1.8.5.</span> <span class="toc-text">8-5：循环体内工作量最小化。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-1：仔细分析有关算法，并进行优化。"><span class="toc-number">1.8.6.</span> <span class="toc-text">½8-1：仔细分析有关算法，并进行优化。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-2：仔细考查、分析系统及模块处理输入（如事务、消息等）的方式，并加以改进。"><span class="toc-number">1.8.7.</span> <span class="toc-text">½8-2：仔细考查、分析系统及模块处理输入（如事务、消息等）的方式，并加以改进。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-3：对模块中函数的划分及组织方式进行分析、优化，改进模块中函数的组织结构，提高程序效率。"><span class="toc-number">1.8.8.</span> <span class="toc-text">½8-3：对模块中函数的划分及组织方式进行分析、优化，改进模块中函数的组织结构，提高程序效率。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-4：编程时，要随时留心代码效率；优化代码时，要考虑周全。"><span class="toc-number">1.8.9.</span> <span class="toc-text">½8-4：编程时，要随时留心代码效率；优化代码时，要考虑周全。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-5：不应花过多的时间拼命地提高调用不很频繁的函数代码效率。"><span class="toc-number">1.8.10.</span> <span class="toc-text">½8-5：不应花过多的时间拼命地提高调用不很频繁的函数代码效率。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-6：要仔细地构造或直接用汇编编写调用频繁或性能要求极高的函数。"><span class="toc-number">1.8.11.</span> <span class="toc-text">½8-6：要仔细地构造或直接用汇编编写调用频繁或性能要求极高的函数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-7：在保证程序质量的前提下，通过压缩代码量、去掉不必要代码以及减少不必要的局部和全局变量，来提高空间效率。"><span class="toc-number">1.8.12.</span> <span class="toc-text">½8-7：在保证程序质量的前提下，通过压缩代码量、去掉不必要代码以及减少不必要的局部和全局变量，来提高空间效率。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-8：在多重循环中，应将最忙的循环放在最内层。"><span class="toc-number">1.8.13.</span> <span class="toc-text">½8-8：在多重循环中，应将最忙的循环放在最内层。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-9：尽量减少循环嵌套层次。"><span class="toc-number">1.8.14.</span> <span class="toc-text">½8-9：尽量减少循环嵌套层次。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-10：避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。"><span class="toc-number">1.8.15.</span> <span class="toc-text">½8-10：避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-11：尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。"><span class="toc-number">1.8.16.</span> <span class="toc-text">½8-11：尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½8-12：不要一味追求紧凑的代码。"><span class="toc-number">1.8.17.</span> <span class="toc-text">½8-12：不要一味追求紧凑的代码。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-质量保证"><span class="toc-number">1.9.</span> <span class="toc-text">9 质量保证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1：在软件设计过程中构筑软件质量。"><span class="toc-number">1.9.1.</span> <span class="toc-text">9-1：在软件设计过程中构筑软件质量。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2：代码质量保证优先原则"><span class="toc-number">1.9.2.</span> <span class="toc-text">9-2：代码质量保证优先原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3：只引用属于自己的存贮空间。"><span class="toc-number">1.9.3.</span> <span class="toc-text">9-3：只引用属于自己的存贮空间。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4：防止引用已经释放的内存空间。"><span class="toc-number">1.9.4.</span> <span class="toc-text">9-4：防止引用已经释放的内存空间。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5：过程-函数中分配的内存，在过程-函数退出之前要释放。"><span class="toc-number">1.9.5.</span> <span class="toc-text">9-5：过程/函数中分配的内存，在过程/函数退出之前要释放。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6：过程-函数中申请的（为打开文件而使用的）文件句柄，在过程-函数退出之前要关闭。"><span class="toc-number">1.9.6.</span> <span class="toc-text">9-6：过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-7：防止内存操作越界。"><span class="toc-number">1.9.7.</span> <span class="toc-text">9-7：防止内存操作越界。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8：认真处理程序所能遇到的各种出错情况。"><span class="toc-number">1.9.8.</span> <span class="toc-text">9-8：认真处理程序所能遇到的各种出错情况。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-9：系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。"><span class="toc-number">1.9.9.</span> <span class="toc-text">9-9：系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-10：系统运行之初，要对加载到系统中的数据进行一致性检查。"><span class="toc-number">1.9.10.</span> <span class="toc-text">9-10：系统运行之初，要对加载到系统中的数据进行一致性检查。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-11：严禁随意更改其它模块或系统的有关设置和配置。"><span class="toc-number">1.9.11.</span> <span class="toc-text">9-11：严禁随意更改其它模块或系统的有关设置和配置。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-12：不能随意改变与其它模块的接口。"><span class="toc-number">1.9.12.</span> <span class="toc-text">9-12：不能随意改变与其它模块的接口。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-13：充分了解系统的接口之后，再使用系统提供的功能。"><span class="toc-number">1.9.13.</span> <span class="toc-text">9-13：充分了解系统的接口之后，再使用系统提供的功能。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-14：编程时，要防止差1错误。"><span class="toc-number">1.9.14.</span> <span class="toc-text">9-14：编程时，要防止差1错误。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-15：要时刻注意易混淆的操作符。当编完程序后，应从头至尾检查一遍这些操作符，以防止拼写错误。"><span class="toc-number">1.9.15.</span> <span class="toc-text">9-15：要时刻注意易混淆的操作符。当编完程序后，应从头至尾检查一遍这些操作符，以防止拼写错误。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-16：有可能的话，if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支。"><span class="toc-number">1.9.16.</span> <span class="toc-text">9-16：有可能的话，if语句尽量加上else分支，对没有else分支的语句要小心对待；switch语句必须有default分支。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-17：Unix下，多线程的中的子线程退出必需采用主动退出方式，即子线程应return出口。"><span class="toc-number">1.9.17.</span> <span class="toc-text">9-17：Unix下，多线程的中的子线程退出必需采用主动退出方式，即子线程应return出口。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-18：不要滥用goto语句。"><span class="toc-number">1.9.18.</span> <span class="toc-text">9-18：不要滥用goto语句。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-1：不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。"><span class="toc-number">1.9.19.</span> <span class="toc-text">½9-1：不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-2：除非为了满足特殊需求，避免使用嵌入式汇编。"><span class="toc-number">1.9.20.</span> <span class="toc-text">½9-2：除非为了满足特殊需求，避免使用嵌入式汇编。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-3：精心地构造、划分子模块，并按“接口”部分及“内核”部分合理地组织子模块，以提高“内核”部分的可移植性和可重用性。"><span class="toc-number">1.9.21.</span> <span class="toc-text">½9-3：精心地构造、划分子模块，并按“接口”部分及“内核”部分合理地组织子模块，以提高“内核”部分的可移植性和可重用性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-4：精心构造算法，并对其性能、效率进行测试。"><span class="toc-number">1.9.22.</span> <span class="toc-text">½9-4：精心构造算法，并对其性能、效率进行测试。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-5：对较关键的算法最好使用其它算法来确认。"><span class="toc-number">1.9.23.</span> <span class="toc-text">½9-5：对较关键的算法最好使用其它算法来确认。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-6：时刻注意表达式是否会上溢、下溢。"><span class="toc-number">1.9.24.</span> <span class="toc-text">½9-6：时刻注意表达式是否会上溢、下溢。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-7：使用变量时要注意其边界值的情况。"><span class="toc-number">1.9.25.</span> <span class="toc-text">½9-7：使用变量时要注意其边界值的情况。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-8：留心程序机器码大小（如指令空间大小、数据空间大小、堆栈空间大小等）是否超出系统有关限制。"><span class="toc-number">1.9.26.</span> <span class="toc-text">½9-8：留心程序机器码大小（如指令空间大小、数据空间大小、堆栈空间大小等）是否超出系统有关限制。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-9：为用户提供良好的接口界面，使用户能较充分地了解系统内部运行状态及有关系统出错情况。"><span class="toc-number">1.9.27.</span> <span class="toc-text">½9-9：为用户提供良好的接口界面，使用户能较充分地了解系统内部运行状态及有关系统出错情况。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-10：系统应具有一定的容错能力，对一些错误事件（如用户误操作等）能进行自动补救。"><span class="toc-number">1.9.28.</span> <span class="toc-text">½9-10：系统应具有一定的容错能力，对一些错误事件（如用户误操作等）能进行自动补救。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-11：对一些具有危险性的操作代码（如写硬盘、删数据等）要仔细考虑，防止对数据、硬件等的安全构成危害，以提高系统的安全性。"><span class="toc-number">1.9.29.</span> <span class="toc-text">½9-11：对一些具有危险性的操作代码（如写硬盘、删数据等）要仔细考虑，防止对数据、硬件等的安全构成危害，以提高系统的安全性。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-12：使用第三方提供的软件开发工具包或控件时，要注意以下几点："><span class="toc-number">1.9.30.</span> <span class="toc-text">½9-12：使用第三方提供的软件开发工具包或控件时，要注意以下几点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½9-13：资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL文件或其它单独的描述文件（如数据库格式）"><span class="toc-number">1.9.31.</span> <span class="toc-text">½9-13：资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL文件或其它单独的描述文件（如数据库格式）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-代码编辑、编译、审查"><span class="toc-number">1.10.</span> <span class="toc-text">10 代码编辑、编译、审查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1：打开编译器的所有告警开关对程序进行编译。"><span class="toc-number">1.10.1.</span> <span class="toc-text">10-1：打开编译器的所有告警开关对程序进行编译。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2：在产品软件（项目组）中，要统一编译开关选项。"><span class="toc-number">1.10.2.</span> <span class="toc-text">10-2：在产品软件（项目组）中，要统一编译开关选项。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3：通过代码走读及审查方式对代码进行检查。"><span class="toc-number">1.10.3.</span> <span class="toc-text">10-3：通过代码走读及审查方式对代码进行检查。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4：测试部测试产品之前，应对代码进行抽查及评审。"><span class="toc-number">1.10.4.</span> <span class="toc-text">10-4：测试部测试产品之前，应对代码进行抽查及评审。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½10-1：编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。"><span class="toc-number">1.10.5.</span> <span class="toc-text">½10-1：编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½10-2：同产品软件（项目组）内，最好使用相同的编辑器，并使用相同的设置选项。"><span class="toc-number">1.10.6.</span> <span class="toc-text">½10-2：同产品软件（项目组）内，最好使用相同的编辑器，并使用相同的设置选项。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½10-3：要小心地使用编辑器提供的块拷贝功能编程。"><span class="toc-number">1.10.7.</span> <span class="toc-text">½10-3：要小心地使用编辑器提供的块拷贝功能编程。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½10-4：合理地设计软件系统目录，方便开发人员使用。"><span class="toc-number">1.10.8.</span> <span class="toc-text">½10-4：合理地设计软件系统目录，方便开发人员使用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½10-5：某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。"><span class="toc-number">1.10.9.</span> <span class="toc-text">½10-5：某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½10-6：使用代码检查工具（如C语言用PC-Lint）对源程序检查。"><span class="toc-number">1.10.10.</span> <span class="toc-text">½10-6：使用代码检查工具（如C语言用PC-Lint）对源程序检查。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½10-7：使用软件工具（如-LogiSCOPE）进行代码审查。"><span class="toc-number">1.10.11.</span> <span class="toc-text">½10-7：使用软件工具（如 LogiSCOPE）进行代码审查。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-代码测试、维护"><span class="toc-number">1.11.</span> <span class="toc-text">11 代码测试、维护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1：单元测试要求至少达到语句覆盖。"><span class="toc-number">1.11.1.</span> <span class="toc-text">11-1：单元测试要求至少达到语句覆盖。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2：单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。"><span class="toc-number">1.11.2.</span> <span class="toc-text">11-2：单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3：清理、整理或优化后的代码要经过审查及测试。"><span class="toc-number">1.11.3.</span> <span class="toc-text">11-3：清理、整理或优化后的代码要经过审查及测试。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4：代码版本升级要经过严格测试。"><span class="toc-number">1.11.4.</span> <span class="toc-text">11-4：代码版本升级要经过严格测试。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5：使用工具软件对代码版本进行维护。"><span class="toc-number">1.11.5.</span> <span class="toc-text">11-5：使用工具软件对代码版本进行维护。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6：正式版本上软件的任何修改都应有详细的文档记录。"><span class="toc-number">1.11.6.</span> <span class="toc-text">11-6：正式版本上软件的任何修改都应有详细的文档记录。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-1：发现错误立即修改，并且要记录下来。"><span class="toc-number">1.11.7.</span> <span class="toc-text">½11-1：发现错误立即修改，并且要记录下来。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-2：关键的代码在汇编级跟踪。"><span class="toc-number">1.11.8.</span> <span class="toc-text">½11-2：关键的代码在汇编级跟踪。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-3：仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。"><span class="toc-number">1.11.9.</span> <span class="toc-text">½11-3：仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-4：尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。"><span class="toc-number">1.11.10.</span> <span class="toc-text">½11-4：尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-5：仔细测试代码处理数据、变量的边界情况。"><span class="toc-number">1.11.11.</span> <span class="toc-text">½11-5：仔细测试代码处理数据、变量的边界情况。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-6：保留测试信息，以便分析、总结经验及进行更充分的测试。"><span class="toc-number">1.11.12.</span> <span class="toc-text">½11-6：保留测试信息，以便分析、总结经验及进行更充分的测试。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-7：不应通过“试”来解决问题，应寻找问题的根本原因。"><span class="toc-number">1.11.13.</span> <span class="toc-text">½11-7：不应通过“试”来解决问题，应寻找问题的根本原因。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-8：对自动消失的错误进行分析，搞清楚错误是如何消失的。"><span class="toc-number">1.11.14.</span> <span class="toc-text">½11-8：对自动消失的错误进行分析，搞清楚错误是如何消失的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-9：修改错误不仅要治表，更要治本。"><span class="toc-number">1.11.15.</span> <span class="toc-text">½11-9：修改错误不仅要治表，更要治本。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-10：测试时应设法使很少发生的事件经常发生。"><span class="toc-number">1.11.16.</span> <span class="toc-text">½11-10：测试时应设法使很少发生的事件经常发生。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-11：明确模块或函数处理哪些事件，并使它们经常发生。"><span class="toc-number">1.11.17.</span> <span class="toc-text">½11-11：明确模块或函数处理哪些事件，并使它们经常发生。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-12：-坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题。"><span class="toc-number">1.11.18.</span> <span class="toc-text">½11-12： 坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#½11-13：去除代码运行的随机性（如去掉无用的数据、代码及尽可能防止并注意函数中的“内部寄存器”等），让函数运行的结果可预测，并使出现的错误可再现。"><span class="toc-number">1.11.19.</span> <span class="toc-text">½11-13：去除代码运行的随机性（如去掉无用的数据、代码及尽可能防止并注意函数中的“内部寄存器”等），让函数运行的结果可预测，并使出现的错误可再现。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-宏"><span class="toc-number">1.12.</span> <span class="toc-text">12 宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1：用宏定义表达式时，要使用完备的括号。"><span class="toc-number">1.12.1.</span> <span class="toc-text">12-1：用宏定义表达式时，要使用完备的括号。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-将宏所定义的多条表达式放在大括号中"><span class="toc-number">1.12.2.</span> <span class="toc-text">12-2:将宏所定义的多条表达式放在大括号中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-使用宏时，不允许参数发生变化。"><span class="toc-number">1.12.3.</span> <span class="toc-text">12-3:使用宏时，不允许参数发生变化。</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>





    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2020/02/29/git-flow/" title="上一篇: Git 分支管理">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/11/09/ATECC508A-config/" title="下一篇: ATECC508A配置案例">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/06/29/secureCRT-setting/">secureCRT设置log自动记录方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/23/disable-tcp-ack-delay/">禁用TCP ACK Delay以提升TCP数据发送性能</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/25/ddr-design/">DDR Design</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/22/si-pi-guide/">信号完整性相关定义</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/29/git-flow/">Git 分支管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/24/hw-code-style-guide/">华为软件编程规范和范例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/ATECC508A-config/">ATECC508A配置案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/28/atecc508a/">ATECC508A开发笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/CryptoAuth/">密码学基本知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/02/cs-ch01/">CSAPP CH1-A Tour of Computer Systems</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/13/altium-rules/">Altium Designer常用规则设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/19/git-guide/">Git学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/31/stm32f767-lwip/">STM32F767上LwIP的移植</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/stm32f767-mpu/">STM32F767 MPU的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/16/stm32f767-sdram/">STM32F767 FMC-SDRAM的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/30/stm32f767-qspi/">STM32F767 QUADSPI的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/27/stm32f767-flash/">STM32F767 Flash的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/21/stm32f767-rtc/">STM32F767 RTC的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/19/stm32f767-uart-dma/">STM32F767 DMA的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/07/stm32f767-pwm/">STM32F767 PWM的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/28/feedforward-cap/">优化前馈电容改善DCDC的瞬态响应(未完成)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/25/stm32f767-wwdg/">STM32F767 WWDG的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/21/stm32f767-iwdg/">STM32F767 IWDG的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/16/stm32f767-timer/">STM32F767 Timer中断的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/08/stm32f767-gpio-it/">STM32F767 GPIO中断的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/05/stm32f767-GPIO-UART/">STM32F767 GPIO与UART的基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/29/stm32f767-delay/">STM32F767 delay函数的HAL库实现与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/stm32f767-system/">STM32F767系统内核与时钟设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/18/stm32f767newpro/">新建一个STM32F767工程(基于HAL库)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/stm32f767-start/">使用STM32CubeMX新建STM32F7工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/12/mlcc-noise/">电源应用中MLCC啸叫问题的分析与解决</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/04/pierce-oscillator/">Pierce振荡器的原理与设计方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/28/F28379D-new-pro-cpu1/">F28379D新建工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/23/python-pyinstaller/">PyInstaller基本用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/14/HDC1010-C2000/">使用F28069驱动温湿度传感器HDC1010</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/14/IEEEStd802-11/">IEEE Std 802.11a/g/n/ac</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/08/XDS100-VCP/">加载C2000 XDS100仿真器的虚拟串口(VCP)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/06/MarkdownSyntax/">Markdown基本语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/21/BuckPowerStage/">Buck电路的功率部分设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/16/myserial/">使用C#构建一个串口程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/09/allegro-guide-2/">Allegro学习笔记-差分线与等长线</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/11/allegro-guide-1/">Allegro学习笔记-基础篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/04/cadence-allegro-package/">使用Ultra Librarian创建Cadence原理图与PCB封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/新建一个C2000工程/">新建一个C2000工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/安装CCS与controlSUITE/">安装CCS与controlSUITE</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2021 焦迪
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>